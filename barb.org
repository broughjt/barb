#+title: Barb
#+date: <2023-12-25 Mon>
#+author: Jackson Brough

* Library
Right now, this project is a formalization of Terence Tao's Analyis I
[cite:@tao2022analysis]. My hope is to continue to other books, but
for now it pretty much directly follows the structure of Tao's book.

While the library is small, I'm going to group things here into a
collection of utilities and then the files for the natural numbers,
integers, rationals, and reals, respectively. This won't correspond
directly to the actual file structure, but I think that's actually a
good thing. If I'm going to maintain some sort of literature component
to this library, I would like it to tell a story about my learning
path, and that will have a very different structure than the code
dependencies between modules.

#+begin_src lean4 :tangle Barb.lean
import «Barb».Algebra
import «Barb».Function
import «Barb».Logic
import «Barb».Order
import «Barb».Quotient
import «Barb».Syntax

import «Barb».Data.Natural
import «Barb».Data.Integer
import «Barb».Data.Rational

import «Barb».Data.Option
#+end_src

** Natural
:PROPERTIES:
:header-args: :tangle Barb/Data/Natural.lean
:END:

"The positive integers and their arithmetic are presupposed by the
very nature of our intelligence and, we are tempted to believe, by the
very nature of intelligence in general. The development of the
positive integers from the primitive concept of the unit, the concept
of adjoining a unit, and the process of mathematical induction carries
complete conviction. In the words of Kronecker, the positive integers
were created by God."

"Kronecker forgot to mention how shoddy the work of man can be."

TODO: Cite

In this module, we construct the natural numbers and develop their
basic algebraic and order theoretic properties.

#+begin_src lean4
import Barb.Function
import Barb.Logic
import Barb.Order
#+end_src

The proofs that follow were my first real exposure to proving things
in Lean. I had worked with Coq tactic proofs before, but I wanted to
understand term-style proofs in Lean instead of just playing Whac-A-Mole
with tactics I didn't understand yet. People talk about how using an
interactive theorem prover can feel like playing a video game: you
look at the current state, you look at the goal state after the
turnstile, and you make moves that get you closer to the goal until
the red squigglies go away. I wanted to use tactics only after I
understood what kind of terms they were generating. Further, a
general goal for this project is to understand the proofs I write. I
should always be able to give a convincing paper proof of any theorem
in here. Unfortunately, there are already exceptions to this, as you
have seen with the two other Peano axioms.

I think starting with pure term-style proofs was very worth it. I
learned how inductive proofs match up with the recursor, and where
before, proofs of equality or negation were totally magic to me in
Coq, they make intuitive sense to me now. After I had done a dozen or
so of these, I read the [[https://leanprover.github.io/theorem_proving_in_lean4/tactics.html][tactics chapter]] in Theorem Proving in Lean 4
and started revising the proofs to use tactics.

What I'll do for the following theorems is provide some explanation,
then show my original term-style proof if it exists (cleaned up a bit
to match how I learned to do things later), and then finally show my
revised tactic-style proof which will be the one that actually gets
tangled. Even so, while writing the natural numbers module I was still
opposed to using much of the rewriter or the simplifier because I
didn't understand how they worked. You'll see me use those tactics
freely in the development of the integers and the rationals, but I
think it's kind of nice to make the proofs here as explicit as
possible. (Psych, there are quite a few theorems in here now which use
~rw~ and ~simp~.)

TODO: Why? Is here a good place to explain the developmental nature of
the writing?

*** Definition, Peano axioms

The inductive definition of the natural numbers starts with an
assumption that we have a zero element in $\mathbb{N}$ -- and yes, the natural
numbers start at zero: people who think the natural numbers start at
one have no class. Then we assume that for any $n$ in $\mathbb{N}$,
the successor $S(n)$ of $n$ is also in $\mathbb{N}$. In type theory,
just like literally everything else, we can represent this structure with an
inductive type.

#+begin_src lean4
inductive Natural where
  | zero : Natural
  | successor : Natural → Natural
#+end_src

This inductive type declaration adds two constructors, ~zero~ and
~successor~, and an eliminator, which is a principle of recursion
and as a special case a principle of induction. These three
correspond to axioms 2.1, 2.2, and 2.5
[cite:@tao2022analysis, p.16-18]. What's cool is that the remaining
Peano axioms are Peano theorems in our construction. This falls out of the
interesting properties of inductive type constructors in type theory,
which I don't fully understand yet.

First, we define conversions between our ~Natural~ type and the built
in ~Nat~ to be able to write $3 : \mathbb{N}$ instead of
~successor(successor(successor(zero))) : Natural~.

#+begin_src lean4
namespace Natural

open Natural (zero successor)

def fromNat : Nat → Natural
  | Nat.zero => Natural.zero
  | Nat.succ n => Natural.successor (fromNat n)

def toNat : Natural → Nat
  | Natural.zero => Nat.zero
  | Natural.successor n => Nat.succ (toNat n)

instance : OfNat Natural n where
  ofNat := fromNat n

instance : ToString Natural where
  toString := toString ∘ toNat

notation "ℕ" => Natural
#+end_src

Tao includes two other Peano axioms. Axiom 2.3 states that zero is not the successor of any natural number,
and axiom 2.4 states that the successor operation is injective, that
is, if $S(n) = S(m)$ then $n = m$.

I went on a long journey trying to understand ~noConfusion~, where I
read [[https://xenaproject.wordpress.com/2018/03/24/no-confusion-over-no_confusion/][No confusion over no_confusion]] and attempted to write my own
version. Unfortunately I'm still mostly confused. I think at one point
I slightly grasped it, but all of that is gone now. I especially don't
understand why the $id$ nonsense works in ~successor_injective~ -- I
just threw terms around until they type checked.

#+begin_src lean4
theorem successor_not_equal_zero (n : ℕ) : successor n ≠ 0 :=
  Natural.noConfusion

theorem successor_injective : Function.Injective successor :=
  λ h => (Natural.noConfusion h) id
#+end_src

Now we prove that the successor of a number is never equal to that
number. The proof works by applying the injectivity of the successor
in the inductive step, forming a long chain of deductive steps stemming
from the fact that zero is not the successor of any element of $\mathbb{N}$.

#+begin_src lean4 :tangle no
theorem successor_not_equal_self' (n : ℕ) : successor n ≠ n :=
  Natural.rec 
    (successor_not_equal_zero 0) 
    (λ _ ih => λ h => ih (successor_injective h))
    n
#+end_src

#+begin_src lean4
theorem successor_not_equal_self (n : ℕ) : successor n ≠ n := by
  induction n with
  | zero => exact successor_not_equal_zero 0
  | successor n ih => intro h; exact ih (successor_injective h)
#+end_src

*** Addition

Addition is defined to be repeated application of the successor. To
add four to five is the same as incrementing five four times. We can
give a recursive definition as follows.

#+begin_src lean4
def add : ℕ → ℕ → ℕ
  | zero, m => m
  | successor n, m => successor (add n m)

instance : Add Natural where
  add := add

@[simp] theorem add_definition : add n m = n + m := rfl
#+end_src

I'm definitely a recurse-on-the-left kind of guy, but we could have
recursed on the right. Now in type theory, this decision actually
bears some consequences due to the distinction between definitional
equality and um... other kinds of equality. That's a whole can of
worms; the type theorists are (rightly) very particular about the
different notions of equality. That's all I say for now, 
because I don't think I do the concepts justice at my current level of
understanding.

In our case, the equations $0 + n = n$ and $S(n) + m = S(n + m)$ hold
definitionally, but $n + 0 = n$ and $n + S(m) = S(n + m)$ require
proof. Luckily we can prove these statements with induction, and then
show that addition is commutative, which will make our choice of
definition less of a big deal.

#+begin_src lean4
theorem zero_add (n : ℕ) : 0 + n = n := rfl

theorem successor_add (n m : ℕ) : (successor n) + m = successor (n + m) := rfl
#+end_src

The proof that $n + 0 = n$ works by rewriting $S(n) + 0$ to $S(n + 0)$
using the definition and then applying the inductive hypothesis, which
claims that $n + 0 = n$ for an arbitary $n : \mathbb{N}$. This is
easier to see in the tactic-style proof.

#+begin_src lean4 :tangle no
theorem add_zero' (n : ℕ) : n + 0 = n := 
  Natural.rec
    (zero_add 0)
    (λ (x : ℕ) (ih : x + 0 = x) =>
      have h1 : (successor x) + 0 = successor (x + 0) := successor_add x 0
      have h2 : successor (x + 0) = (successor x) + 0 := Eq.symm h1
      have h3 : successor x = (successor x) + 0 := 
        Eq.subst (motive := λ a => successor a = (successor x) + 0)
          ih
          h2
      show (successor x) + 0 = successor x from Eq.symm h3)
    n
#+end_src

#+begin_src lean4
@[simp] theorem add_zero (n : ℕ) : n + 0 = n := by
  induction n with
  | zero => exact zero_add 0
  | successor n ih => calc
    (successor n) + 0 = successor (n + 0) := successor_add n 0
    _                 = successor n       := congrArg successor ih
#+end_src


When I wrote the term-style proof, I didn't know about ~congrArg~ and
so I had to hack together equality substitutions, which is what
~congrArg~ generalizes. I also used the ~have~ and ~show~ keywords,
since they are just nice ways of writing ~let~ and explicitly
declaring the type of an expression, respectively, and this didn't
feel like any big jump from pure lambda terms.

The tactic style proof is much cleaner. While writing the naturals, I
really got into the calc-mode style of lining up transitive relations
step-wise.

The next proof is very similar to the last theorem: we do two
rewrites using the definition of addition and the inductive hypothesis
and we're done. I discovered ~congrArg~ while writing the term-style
proof for this one. It's awesome; it saves you from having to
prove the same throw-away mini lemmas over and over.

#+begin_src lean4 :tangle no
theorem add_successor' (n m : ℕ) : n + (successor m) = successor (n + m) :=
  Natural.rec
    (
      have h1 : 0 + (successor m) = successor m := zero_add (successor m)
      -- congrArg to the rescue!
      have h2 : successor (0 + m) = successor m := congrArg successor (zero_add m)
      show 0 + (successor m) = successor (0 + m) from Eq.trans h1 (Eq.symm h2)
    )
    (λ (x : ℕ) (ih : x + (successor m) = successor (x + m)) =>
      have h1 : (successor x) + (successor m) = successor (x + (successor m)) := successor_add x (successor m)
      have h2 : successor (x + (successor m)) = successor (successor (x + m)) := congrArg successor ih
      -- Little extra help from the compiler since (successor x) + m) is definitionally equal to sucessor (x + m)
      show (successor x) + (successor m) = successor ((successor x) + m) from Eq.trans h1 h2
    )
    n
#+end_src

#+begin_src lean4
theorem add_successor (n m : ℕ) : n + (successor m) = successor (n + m) := by
  induction n with
  | zero => calc
    0 + (successor m) = successor m       := zero_add (successor m)
    _                 = successor (0 + m) := congrArg successor (zero_add m)
  | successor n ih => calc
    (successor n) + (successor m) = successor (n + (successor m)) := successor_add n (successor m)
    _                             = successor (successor (n + m)) := congrArg successor ih
#+end_src

Now we develop the commutativity, associativity, and cancellation laws
for addition.

Why is addition commutative? Incrementing $n$ 5 times always gives the same
result as incrementing 5 $n$ times. This bears itself it out in the
proof: we make direct use of the two theorems we just proved. I had
term-style proofs of all of these, but I will spare you.

#+begin_src lean4
theorem add_commutative (n m : ℕ) : n + m = m + n := by
  induction n with
  | zero => calc
    0 + m = m     := zero_add m
    _     = m + 0 := (add_zero m).symm
  | successor n ih => calc
    (successor n) + m = successor (n + m) := successor_add n m
    _                 = successor (m + n) := congrArg successor ih
    _                 = m + (successor n) := (add_successor m n).symm
#+end_src

It's a bit harder to come with an intuitive explanation for
associativity. The order just doesn't matter man, that's all I have
for you. The proof's nice though, you just move the successor to the
front using the theorems we developed for right-hand side successor
addition and then you rewrite inside the successor using the inductive
hypothesis.

#+begin_src lean4
theorem add_associative (n m k : ℕ) : (n + m) + k = n + (m + k) := by
  induction n with
  | zero => calc
    (0 + m) + k = m + k       := congrArg (. + k) (zero_add m)
    _           = 0 + (m + k) := zero_add (m + k)
  | successor n ih => calc
    ((successor n) + m) + k = (successor (n + m)) + k := congrArg (. + k) (successor_add n m)
    _                       = successor ((n + m) + k) := successor_add (n + m) k
    _                       = successor (n + (m + k)) := congrArg successor ih
#+end_src

These lemmas end up being useful in the future when you're rewriting
heavily nested expressions, but they really should just not exist; if
only the simplifier was better.

#+begin_src lean4
theorem add_left_commutative (n m k : ℕ) : n + (m + k) = m + (n + k) := by
  rw [← add_associative, add_commutative n m, add_associative]
  
theorem add_right_commutative (n m k : ℕ) : (n + m) + k = (n + k) + m := by
  rw [add_associative, add_commutative m k, ← add_associative]
#+end_src

Addition is left cancellative because, well, if $n + m$ and
$n + k$ are the same value, then $m$ had better equal $k$ -- that's
why. The real proof is inductive and utilizes the fact that zero is an
additive identity and that the successor is injective.

#+begin_src lean4
theorem add_left_cancel {n m k : ℕ} : n + m = n + k → m = k := by
  induction n with
  | zero => 
    intro h
    calc
      m = 0 + m := zero_add m
      _ = 0 + k := h
      _ = k     := zero_add k
  | successor n ih =>
    intro h
    have := calc
      successor (n + m) = (successor n) + m := (successor_add n m).symm
      _                 = (successor n) + k := h
      _                 = successor (n + k) := successor_add n k
    exact ih (successor_injective this)

theorem add_right_cancel {n m k : ℕ} (h : n + k = m + k) : n = m := by
  rw [add_commutative n k, add_commutative m k] at h
  exact add_left_cancel h
#+end_src

*** Decidable equality

The law of the excluded middle essentially claims that every
proposition is decidable, that is, that $p \lor \neg p$ holds for any
proposition $p$. Once you're cool to give this up, there is this really cool
distinction between decidable and non-decidable propositions. Even
though it doesn't hold in the general case, you can show that certain
classes of propositions /are/ decidable.

You accomplish this by giving a _decision procedure_ which shows how
to "decide" a predicate -- and mind you, a predicate is a function
which sends values to propositions, or a value-indexed family of
propositions. It is /not/ a function which returns a
boolean. Identifying statements with elements of $\{\top, \bot\}$ is
something from classical logic that feels super weird to me.

A little more formally, a decision procedure takes a predicate of the
form ~p : α → Prop~ and an element of that type ~a : α~, and _decides_
~p a~ by providing a proof of ~p a~ or a proof ~¬(p a)~. Giving a
decision procedure for a predicate ~p~ shows that ~p~ is _decidable_,
because given any instance ~a : α~, we have an algorithm for showing
whether ~p a~ or not ~p a~.

This section has gone through several different iterations, but the
latest version includes a small grouping of lemmas about the
~distance~ function for natural numbers, which basically gives the
absolute value difference between the two values, except that we don't
compute it using subtraction, because we tried that earlier and
natural number subtraction is super broken hack.

You'll notice that I'm totally willing to use the ~rw~ and ~simp~
tactics here. This might feel anachronistic, since I avoid them
everywhere else in the natural number proofs, and that's because it is:
I came from the future because I needed these theorems for the integers.

#+begin_src lean4
@[simp]
def distance : ℕ → ℕ → ℕ
  | zero, zero => 0
  | successor n, zero => successor n
  | zero, successor m => successor m
  | successor n, successor m => distance n m

theorem equal_of_distance_equal_zero : ∀ {n m : ℕ}, distance n m = 0 → n = m
  | zero, zero, _ => rfl
  | successor n, successor m, h => by
    unfold distance at h
    exact congrArg successor (equal_of_distance_equal_zero h)

theorem distance_equal_zero_of_equal : ∀ {n m : ℕ}, n = m → distance n m = 0
  | zero, zero, _ => rfl
  | successor n, successor m, h => by
    unfold distance
    exact distance_equal_zero_of_equal (successor_injective h)

theorem distance_self : ∀ (n : ℕ), distance n n = 0 :=
  λ _ => distance_equal_zero_of_equal rfl

theorem distance_zero_left : ∀ (n : ℕ), distance n 0 = n
  | zero => rfl
  | successor n => by unfold distance; rfl

theorem distance_commutative : ∀ (n m : ℕ), distance n m = distance m n
  | zero, zero => distance_zero_left _
  | zero, successor _ => distance_zero_left (successor _)
  | successor _, zero => distance_zero_left (successor _)
  | successor _, successor _ => by
    simp
    apply distance_commutative

theorem distance_zero_right (n : ℕ) : distance 0 n = n := by
  rw [distance_commutative, distance_zero_left]

theorem distance_add_add_right (n m k : ℕ) : distance (n + k) (m + k) = distance n m := by
  induction k with
  | zero =>
    have this : zero = 0 := rfl
    simp [this, add_zero]
  | successor k ih =>
    simp [add_successor]
    exact ih

theorem distance_add_add_left (n m k : ℕ) : distance (n + m) (n + k) = distance m k := by
  rw [add_commutative n m, add_commutative n k, distance_add_add_right]
#+end_src

I still can't figure out what to call this next theorem. It states
that if two sums are equal, the distance between the first terms of
each sum must be made up for exactly in the distance between the
second terms. Writing this out visually is also compelling. Arrange
two equal length lines cut into two different length segments, name
the segments $n$, $m$, $k$, and $l$, and then arrange a copy of each
segment vertically so that their left ends line up. It will become
apparent that the difference in lengths between $n$ and $k$ match up
with the difference between $l$ and $m$.

#+begin_src lean4
theorem distance_equal_of_add_equal {n m k l : ℕ} (h : n + m = k + l) : distance n k = distance l m := by
  calc
    distance n k = distance (n + m) (k + m) := (distance_add_add_right n k m).symm
    _ = distance (k + l) (k + m) := congrArg (λ x => distance x _) h
    _ = distance l m := distance_add_add_left k l m
#+end_src

Since we have shown that $\mathnormal{distance}(n, m) = 0$ and $n = m$
are logically equivalent, we can use the distance function to decide
equality. This will be a common theme: when we develop decision
procedures for equality or other relations, we often establish a
logical equivalence between something we know how to compute and the
proposition we want to decide. The connection between decidable
propositions, computability, and computational complexity seems to be
very important, and I'm interested to go deeper on this idea.

#+begin_src lean4
instance decideEqual : DecidableEq Natural
  | n, m => match h : distance n m with
    | zero => isTrue (equal_of_distance_equal_zero h)
    | successor a => isFalse (mt distance_equal_zero_of_equal (h ▸ successor_not_equal_zero a))
#+end_src

Corollary 2.2.9 [cite:@tao2022analysis, p. 26] utilizes proof by
contradiction. Corollaries are supposed to follow easily from a
previously stated theorem, but without being able to prove it with
contradiction, the proof of ~equal_zero_of_add_equal_zero~ was way,
way more involved then ~add_positive~, which it was supposed to follow
from. Now that we have decidability, we can employ our classical proof
methods locally. Specifically, we use double negation here, which in
this case says that that $\neg \neg n = m \to n = m$.

#+begin_src lean4
theorem add_positive {n m : ℕ} : n ≠ 0 → (n + m) ≠ 0 :=
  match n with
  | zero => absurd rfl
  | successor n => λ _ => successor_not_equal_zero (n + m)

theorem equal_zero_of_add_equal_zero {n m : ℕ} (h : n + m = 0) : n = 0 ∧ m = 0 := by
  apply And.intro
  . exact Decidable.of_not_not (mt add_positive (not_not_intro h))
  . have : m + n = 0 := (add_commutative n m).symm.trans h
    exact Decidable.of_not_not (mt add_positive (not_not_intro this))

theorem unique_predecessor_of_positive {n : ℕ} : n ≠ 0 → ∃! (m : ℕ), successor m = n :=
  match n with
  | zero => absurd rfl
  | successor n => λ _ => ExistsUnique.introduction n rfl (λ _ => successor_injective)
#+end_src

*** Order

Remember when I said that people with class start the natural numbers
out at zero? Well now we get to reap the benefits of our correct decision
making. Let $n$ and $m$ be natural numbers. We say the $n$ is less
than or equal to $m$ if there exists a natural number $a$ for which
$n + a = m$. We say that $n$ is strictly less than $m$ when $a$ is
positive, that is, when it is nonzero (we don't have negative numbers
yet).

#+begin_src lean4
def LessEqual (n m : ℕ) : Prop := ∃ (a : ℕ), n + a = m

instance : LE Natural where
  le := LessEqual

@[simp] theorem less_equal_definition : (LessEqual n m) = (n ≤ m) := rfl
#+end_src

In my opinion, making less than or equal the more primitive
notion makes the proofs cleaner, and at any rate, this is how Tao
defines things too (until the rationals where he switches things up on
you out of nowhere -- what's that about).

Now we show that the less than or equal relation forms a total order on the
natural numbers, and we give a decision procedure for less than or equal as
well. A total order requires that a relation be reflexive,
antisymmetric, transitive, and strongly connected, which altogether
basically allows us to stick any two natural numbers on a line and
compare their relative positions. TODO this is bad informal
explanation.

First, the less equal relation is reflexive, that is, we have $n \le n$ for
any $n : \mathbb{N}$, because zero is an additive identity.

#+begin_src lean4
@[simp] theorem LessEqual.reflexive : Relation.Reflexive LessEqual :=
  λ n => Exists.intro 0 (add_zero n)
#+end_src

Being antisymmetric means that there are no two distinct elements which are
related to each other in both directions, which we state logically as
$n \le m \to m \le n \to n = m$ for all $n, m : \mathbb{N}$. To show this, we prove
$n + (a + b) = n + 0$ must hold by substituting in both hypotheses,
which implies $a + b = 0$. For natural numbers, this means $a$ and
$b$ must both be zero, and therefore $n = m$.

#+begin_src lean4
theorem LessEqual.antisymmetric : Relation.AntiSymmetric LessEqual := by
  intro n m ⟨a, (ha : n + a = m)⟩ ⟨b, (hb : m + b = n)⟩
  suffices a + b = 0 by 
  { have ⟨a_zero, _⟩ := equal_zero_of_add_equal_zero this
    rw [← add_zero n, ← a_zero, ha] }
  apply add_left_cancel (n := n)
  rw [← add_associative, ha, hb, add_zero]
#+end_src

To show that the less equal relation is transitive, just substitute
the equation for the first definition into the equation for the
second. Nice.

#+begin_src lean4
theorem LessEqual.transitive : Relation.Transitive LessEqual := by
  intro n m k ⟨a, (ha : n + a = m)⟩ ⟨b, (hb : m + b = k)⟩
  apply Exists.intro (a + b)
  rw [← add_associative, ha, hb]
#+end_src

Now we have shown that less equal is a partial order, but before we
show strong connectedness, we will develop a decision procedure for
less equal, because I couldn't come up with a nice proof for strong
connectedness without just deferring to decidability in a double
induction argument. You'll see what I mean. To make a decision
procedure, we need a few lemmas first.

#+begin_src lean4
@[simp] theorem zero_less_equal (n : ℕ) : 0 ≤ n := 
  Exists.intro n (zero_add n)
  
theorem equal_zero_of_less_equal_zero : ∀ {n : ℕ}, n ≤ 0 → n = 0 := by
  intro n ⟨a, (h: n + a = 0)⟩
  have := equal_zero_of_add_equal_zero h
  exact this.left
  
theorem less_equal_of_successor_less_equal_successor {n m : ℕ} : successor n ≤ successor m → n ≤ m := by
  intro ⟨a, (h : successor n + a = successor m)⟩
  apply Exists.intro a
  apply successor_injective
  rw [← successor_add, h]
  
theorem successor_less_equal_successor_of_less_equal {n m : ℕ} : n ≤ m → successor n ≤ successor m := by
  intro ⟨a, (h : n + a = m)⟩
  have := calc
    successor n + a = successor (n + a) := successor_add _ _
    _ = successor m := congrArg successor h
  exact Exists.intro a this
  
theorem less_equal_successor_of_less_equal {n m : ℕ} : n ≤ m → n ≤ successor m := by
  intro ⟨a, (h : n + a = m)⟩
  have := calc
    n + successor a = successor (n + a) := add_successor _ _
    _ = successor m := congrArg successor h
  exact Exists.intro (successor a) this
#+end_src

We also need a boolean less equal function. The two lemmas following
that show that the output of this function is logically consistent
with the propositional version.

#+begin_src lean4
def booleanLessEqual : ℕ → ℕ → Bool
  | zero, zero => true
  | zero, successor _ => true
  | successor _, zero => false
  | successor n, successor m => booleanLessEqual n m

theorem less_equal_of_boolean_less_equal_true {n m : ℕ} (h : (booleanLessEqual n m) = true) : n ≤ m :=
  match n, m with
  | zero, _ => zero_less_equal _
  | successor _, successor _ => successor_less_equal_successor_of_less_equal (less_equal_of_boolean_less_equal_true h)
  
theorem boolean_less_equal_true_of_less_equal : ∀ {n m : ℕ}, n ≤ m → (booleanLessEqual n m) = true
  | zero, m, _ => by cases m <;> rfl
  | successor n, successor m, h => by
    rw [booleanLessEqual]
    have := less_equal_of_successor_less_equal_successor h
    exact boolean_less_equal_true_of_less_equal this
#+end_src

Now the decision procedure is easy: run the function and apply the
lemmas we proved to show that this function suffices to decide the proposition
in both cases.

#+begin_src lean4
instance decideLessEqual (n m : ℕ) : Decidable (n ≤ m) :=
  if h : (booleanLessEqual n m) = true then
    isTrue (less_equal_of_boolean_less_equal_true h)
  else
    isFalse (mt boolean_less_equal_true_of_less_equal h)
#+end_src

Now we can use decidability to show strong connectedness, which tells
us that any two elements are comparable. I don't have any better
justification for this fact other than that it holds if one of the
elements is zero, and that this holds inductively because we proved
$n \le m$ implies $S(n) \le S(m)$.

#+begin_src lean4
theorem LessEqual.strongly_connected : Relation.StronglyConnected LessEqual
  | zero, _ => Or.inl (zero_less_equal _)
  | successor _, zero => Or.inr (zero_less_equal _)
  | successor n, successor m =>
    Or.implies 
      successor_less_equal_successor_of_less_equal 
      successor_less_equal_successor_of_less_equal 
      (LessEqual.strongly_connected n m)
#+end_src

Together these properties show that less equal forms a total order for
the natural numbers.

#+begin_src lean4
instance totalOrder : DecidableTotalOrder Natural where
  less_equal_reflexive := LessEqual.reflexive
  less_equal_antisymmetric := LessEqual.antisymmetric
  less_equal_transitive := LessEqual.transitive
  less_equal_strongly_connected := LessEqual.strongly_connected
  decideEqual := decideEqual
  decideLessEqual := decideLessEqual
#+end_src

Because order theory is awesome, every total order induces a strict
total order, so we get the less than relation for free. It is defined
by $n \le m \land \neg (m \le n)$. See the order theory module for the
interesting details.

#+begin_src lean4
def LessThan : ℕ → ℕ → Prop := strictPartialOrderOfPreorder.lt
#+end_src

The rest of this stuff is a hodge podge of very trivial statements about
order. The important ones are

- ~add_left_less_equal~:
  $\forall n, m, k : \mathbb{N}, m \le k \to n + m \le n + k$
- ~less_equal_of_add_left_less_equal~:
  $\forall n, m, k : \mathbb{N}, n + m \le n + k \to m \le k$
- ~equal_add_positive_of_less_than~:
  $\forall n, m : \mathbb{N}, n < m \to (\exists a : \mathbb{N}, a \ne
  0 \land n + a = m)$
- ~less_than_of_equal_add_positive~:
  $\forall n, m, a : \mathbb{N}, a \ne 0 \land n + a = m \to n < m$

There are also ~less_than~ versions for the first two.

#+begin_src lean4
theorem less_than_successor (n : ℕ) : n < successor n :=
  have := less_than_or_equal_of_less_equal (less_equal_successor_of_less_equal (less_equal_reflexive n))
  Or.resolve_right this (successor_not_equal_self n).symm

theorem less_than_of_successor_less_equal {n m : ℕ} (h : successor n ≤ m) : n < m :=
  less_than_of_less_than_of_less_equal (less_than_successor n) h

theorem less_than_successor_of_less_equal {n m : ℕ} (h : n ≤ m) : n < successor m := 
  less_than_of_less_equal_of_less_than h (less_than_successor m)

theorem successor_less_equal_of_less_than {n m : ℕ} (h : n < m) : successor n ≤ m :=
  have ⟨a, (ha : n + a = m)⟩ := less_equal_of_less_than h
  have hnm := not_equal_of_less_than h
  match a with
  | zero => absurd ((add_zero _).symm.trans ha) hnm
  | successor a => 
    have := calc
      successor n + a = successor (n + a) := successor_add _ _
      _ = n + successor a := (add_successor _ _).symm
      _ = m := ha
    Exists.intro a this

theorem less_equal_of_successor_less_equal {n m : ℕ} : successor n ≤ m → n ≤ m := 
  less_equal_of_less_than ∘ less_than_of_successor_less_equal
    
theorem less_than_of_successor_less_than_successor {n m : ℕ} : successor n < successor m → n < m :=
  less_than_of_successor_less_equal ∘ less_equal_of_successor_less_equal_successor ∘ successor_less_equal_of_less_than

theorem equal_zero_or_positive (n : ℕ) : n = 0 ∨ n > 0 :=
  Or.implies_left 
  Eq.symm
  (Or.commutative.mp (less_than_or_equal_of_less_equal (zero_less_equal n)))

theorem not_successor_less_equal_zero (n : ℕ) : ¬(successor n ≤ 0) := by
  intro ⟨a, (ha : successor n + a = 0)⟩
  rw [successor_add] at ha
  exact (successor_not_equal_zero _) ha

theorem zero_less_than_successor (n : ℕ) : successor n > 0 :=
  Or.resolve_left (equal_zero_or_positive (successor n)) (successor_not_equal_zero _)

theorem not_less_than_zero (n : ℕ) : ¬(n < 0) :=
  λ h => not_successor_less_equal_zero n (successor_less_equal_of_less_than h)

theorem zero_less_than_positive {n : ℕ} : n ≠ 0 → 0 < n :=
  Or.resolve_left (equal_zero_or_positive n)
  
theorem nonzero_of_less_than {n m : ℕ} (h : n < m) : m ≠ 0 :=
  match m with
  | zero => absurd h (not_less_than_zero _)
  | successor _ => successor_not_equal_zero _

theorem add_left_less_equal {m k : ℕ} (h : m ≤ k) (n : ℕ) : n + m ≤ n + k :=
  let ⟨a, (h₁ : m + a = k)⟩ := h
  have := calc
    n + m + a = n + (m + a) := add_associative n m a
    _         = n + k       := congrArg (n + .) h₁
  Exists.intro a this

theorem add_right_less_equal {n m : ℕ} (h : n ≤ m) (k : ℕ) : n + k ≤ m + k := by
  rw [add_commutative n k, add_commutative m k]
  exact add_left_less_equal h k
    
theorem add_left_less_than {m k : ℕ} (h : m < k) (n : ℕ) : n + m < n + k := by
  have := add_left_less_equal (successor_less_equal_of_less_than h) n
  apply less_than_of_successor_less_equal
  calc
    successor (n + m) = n + successor m := (add_successor _ _).symm
    _ ≤ n + k := this

theorem add_right_less_than {n m : ℕ} (h : n < m) (k : ℕ) : n + k < m + k := by
  rw [add_commutative n k, add_commutative m k]
  exact add_left_less_than h k

theorem less_equal_of_add_left_less_equal {n m k : ℕ} (h : n + m ≤ n + k) : m ≤ k :=
  let ⟨a, (ha : (n + m) + a = n + k)⟩ := h
  have := calc
    n + (m + a) = (n + m) + a := (add_associative n m a).symm
    _           = n + k       := ha
  Exists.intro a (add_left_cancel this)

theorem less_equal_of_add_right_less_equal {n m k : ℕ} (h : n + k ≤ m + k) : n ≤ m := by
  rw [add_commutative n k, add_commutative m k] at h 
  exact less_equal_of_add_left_less_equal h
  
theorem less_than_of_add_left_less_than {n m k : ℕ} (h : n + m < n + k) : m < k :=
  have := calc
    n + successor m = successor (n + m) := add_successor _ _
    _ ≤ n + k := successor_less_equal_of_less_than h
  less_than_of_successor_less_equal (less_equal_of_add_left_less_equal this)

theorem less_than_of_add_right_less_than {n m k : ℕ} (h : n + k < m + k) : n < m := by
  rw [add_commutative n k, add_commutative m k] at h 
  exact less_than_of_add_left_less_than h

theorem equal_add_positive_of_less_than {n m : ℕ} (h : n < m) : 
  ∃ (a : ℕ), a ≠ 0 ∧ n + a = m := by
  let ⟨a, (ha : (successor n) + a = m)⟩ := successor_less_equal_of_less_than h
  apply Exists.intro (successor a)
  apply And.intro
  . exact successor_not_equal_zero a
  . calc
      n + (successor a) = successor (n + a) := add_successor _ _
      _                 = (successor n) + a := (successor_add _ _).symm
      _                 = m                 := ha

theorem less_than_of_equal_add_positive {n m a : ℕ} : a ≠ 0 → n + a = m → n < m := by
  intro a_not_zero ha
  let ⟨b, (hb : successor b = a), _⟩ := (unique_predecessor_of_positive a_not_zero)
  have := calc
    successor n + b = successor (n + b) := successor_add _ _
    _ = n + successor b := (add_successor _ _ ).symm
    _ = n + a := congrArg (_ + .) hb
    _ = m := ha
  exact less_than_of_successor_less_equal (Exists.intro b this)

theorem left_greater_equal_of_add_right_less_equal {n m k l : ℕ} : n + m = k + l → m ≤ l → n ≥ k := by
  intro h_equal ⟨a, (ha : m + a = l)⟩
  apply Exists.intro a
  apply add_left_cancel (n := m)
  rw [add_left_commutative, ha, ← h_equal, add_commutative]
  
theorem right_greater_equal_of_add_left_less_equal {n m k l : ℕ} : n + m = k + l → n ≤ k → m ≥ l := by
  intro h_equal h_less_equal
  rw [add_commutative n m, add_commutative k l] at h_equal
  exact left_greater_equal_of_add_right_less_equal h_equal h_less_equal
#+end_src

*** Multiplication

We define multiplication similarly to addition: just like addition was
iterated incrementation, multiplication is iterated addition.

#+begin_src lean4
def multiply : ℕ → ℕ → ℕ
  | zero, _ => 0
  | successor n, m => (multiply n m) + m

instance : Mul Natural where
  mul := multiply

@[simp] theorem multiply_definition : multiply n m = n * m := rfl
#+end_src

We show that multiplication satisfies the commutative, associative,
and left and right distributive properties.

#+begin_src lean4
@[simp] theorem zero_multiply (n : ℕ) : 0 * n = 0 := rfl

theorem successor_multiply (n m : ℕ) : (successor n) * m = (n * m) + m := rfl

@[simp] theorem multiply_zero (n : ℕ) : n * 0 = 0 := by
  induction n with
  | zero => rfl
  | successor n ih =>
    calc
      (successor n) * 0 = (n * 0) + 0 := successor_multiply n 0
      _                 = n * 0       := add_zero (n * 0)
      _                 = 0           := ih

theorem multiply_successor (n m : ℕ) : n * (successor m) = (n * m) + n := by
  induction n with
  | zero => rfl
  | successor n ih =>
    show (successor n) * (successor m) = ((successor n) * m) + (successor n)
    calc
      (successor n) * (successor m)
        = n * (successor m) + (successor m)   := successor_multiply n (successor m)
      _ = ((n * m) + n) + (successor m)       := congrArg (. + successor m) ih
      _ = (n * m) + (n + (successor m))       := add_associative (n * m) n (successor m)
      _ = (n * m) + successor (n + m)         := congrArg (n * m + .) (add_successor n m)
      _ = (n * m) + ((successor n) + m)       := congrArg (n * m + .) (successor_add n m).symm
      _ = (n * m) + (m + (successor n))       := congrArg (n * m + .) (add_commutative (successor n) m)
      _ = ((n * m) + m) + (successor n)       := (add_associative (n * m) m (successor n)).symm
      _ = ((successor n) * m) + (successor n) := congrArg (. + (successor n)) (successor_multiply n m).symm

theorem multiply_commutative (n m : ℕ) : n * m = m * n := by
  induction n with
  | zero =>
    calc
      0 * m = 0     := zero_multiply m
      _     = m * 0 := (multiply_zero m).symm
  | successor n ih =>
    calc
      (successor n) * m = (n * m) + m       := successor_multiply n m
      _                 = (m * n) + m       := congrArg (. + m) ih
      _                 = m * (successor n) := (multiply_successor m n).symm

theorem left_distributive (n m k : ℕ) : n * (m + k) = n * m + n * k := by
  induction k with
  | zero => calc
    n * (m + 0) = n * m         := congrArg (n * .) (add_zero m)
    _           = n * m + 0     := (add_zero (n * m)).symm
    _           = n * m + n * 0 := congrArg ((n * m) + .) (multiply_zero n).symm
  | successor k ih => calc
    n * (m + successor k)
      = n * successor (m + k)     := congrArg (n * .) (add_successor m k)
    _ = (n * (m + k)) + n         := multiply_successor n (m + k)
    _ = (n * m + n * k) + n       := congrArg (. + n) ih
    _ = n * m + (n * k + n)       := add_associative (n * m) (n * k) n
    _ = n * m + n * (successor k) := congrArg (n * m + .) (multiply_successor n k).symm

theorem right_distributive (n m k : ℕ) : (n + m) * k = n * k + m * k := by
  calc
    (n + m) * k = k * (n + m)   := multiply_commutative (n + m) k
    _           = k * n + k * m := left_distributive k n m
    _           = n * k + k * m := congrArg (. + k * m) (multiply_commutative k n)
    _           = n * k + m * k := congrArg (n * k + .) (multiply_commutative k m)

theorem multiply_associative (n m k : ℕ) : (n * m) * k = n * (m * k) := by
  induction n with
  | zero => calc
    (0 * m) * k = 0 * k       := congrArg (. * k) (zero_multiply m)
    _           = 0           := zero_multiply k
    _           = 0 * (m * k) := (zero_multiply (m * k)).symm
  | successor n ih => calc
    (successor n * m) * k
      = (n * m + m) * k       := congrArg (. * k) (successor_multiply n m)
    _ = ((n * m) * k) + m * k := right_distributive (n * m) m k
    _ = (n * (m * k)) + m * k := congrArg (. + m * k) ih
    _ = successor n * (m * k) := successor_multiply n (m * k)
#+end_src

Then for convience we give several lemmas which follow from these properties.

#+begin_src lean4
@[simp] theorem one_multiply (n : ℕ) : 1 * n = n := rfl

@[simp] theorem multiply_one (n : ℕ) : n * 1 = n := (multiply_commutative n 1).trans (one_multiply n)

theorem equal_zero_of_multiply_equal_zero {n m : ℕ} : n * m = 0 → n = 0 ∨ m = 0 :=
  match n with
  | zero => λ _ => Or.inl rfl
  | successor n =>
    λ h =>
    have h₁ : (n * m) + m = 0 := (successor_multiply n m).symm.trans h
    have h₂ : (n * m) = 0 ∧ m = 0 := equal_zero_of_add_equal_zero h₁
    Or.inr h₂.right

theorem multiply_equal_zero_of_equal_zero {n m : ℕ} : n = 0 ∨ m = 0 → n * m = 0 := by
  intro h
  cases h with
  | inl n_equal_zero => calc
    n * m = 0 * m := congrArg (. * m) n_equal_zero
    _     = 0     := zero_multiply m
  | inr m_equal_zero => calc
    n * m = n * 0 := congrArg (n * .) m_equal_zero
    _     = 0     := multiply_zero n

theorem positive_of_multiply_positive {n m : ℕ} (h : n * m ≠ 0) : n ≠ 0 ∧ m ≠ 0 :=
  have : ¬(n = 0 ∨ m = 0) := mt multiply_equal_zero_of_equal_zero h
  not_or.mp this

theorem multiply_positive_of_positive {n m : ℕ} (hn : n ≠ 0) (hm : m ≠ 0) : n * m ≠ 0 :=
  have : ¬(n = 0 ∨ m = 0) := not_or.mpr (And.intro hn hm)
  mt equal_zero_of_multiply_equal_zero this

theorem multiply_left_commutative (n m k : ℕ) : n * (m * k) = m * (n * k) := by
  rw [← multiply_associative, multiply_commutative n m, multiply_associative]

theorem multiply_right_commutative (n m k : ℕ) : (n * m) * k = (n * k) * m := by
  rw [multiply_associative, multiply_commutative m k, ← multiply_associative]
#+end_src

Finally, we show that multiplication by a nonzero natural number
respects the order relation, and use this to prove the cancellation
law for multiplication.

#+begin_src lean4
theorem multiply_left_less_than {m k : ℕ} (h_less_than : m < k) (n : ℕ) (hn_positive : n ≠ 0) : n * m < n * k := by
  let ⟨a, ⟨(ha_positive : a ≠ 0), (h_exists : m + a = k)⟩⟩ := equal_add_positive_of_less_than h_less_than
  apply less_than_of_equal_add_positive
  . show n * a ≠ 0
    exact multiply_positive_of_positive hn_positive ha_positive
  . calc
    n * m + n * a = n * (m + a) := (left_distributive n m a).symm
    _             = n * k       := congrArg (n * .) h_exists

theorem multiply_left_cancel {n m k : ℕ} (h_equal : n * m = n * k) (h_positive : n ≠ 0) : m = k :=
  match less_than_trichotomous m k with
  | Or.inl h_less_than =>
    have : n * m ≠ n * k := not_equal_of_less_than (multiply_left_less_than h_less_than n h_positive)
    absurd h_equal this
  | Or.inr (Or.inl h_equal) => h_equal
  | Or.inr (Or.inr h_greater_than) =>
    have : n * k ≠ n * m := not_equal_of_less_than (multiply_left_less_than h_greater_than n h_positive)
    absurd h_equal this.symm

theorem multiply_right_cancel {n m k : ℕ} (h_equal : n * k = m * k) (h_positive : k ≠ 0) : n = m :=
  have := calc
    k * n = n * k := multiply_commutative k n
    _     = m * k := h_equal
    _     = k * m := multiply_commutative m k
  multiply_left_cancel this h_positive

#+end_src

*** Division algorithm, exponentiation

This just a stub for now, I would like to rewrite ~quotient_remainder~
into a type-level algorithm using subtypes and rename it to ~divideWithRemainder~.

#+begin_src lean4
theorem quotient_remainder {n q : ℕ} (q_positive : q ≠ 0) :
  ∃ (p : ℕ × ℕ),
  let ⟨m, r⟩ := p; n = m * q + r ∧ r < q := by
  induction n with
  | zero =>
    apply Exists.intro ⟨0, 0⟩
    apply And.intro
    . calc
      0 = 0 * q := (zero_multiply q).symm
      _ = (0 * q) + 0 := (add_zero (0 * q)).symm
    . have h_exists : 0 + q = q := zero_add q
      exact less_than_of_equal_add_positive q_positive h_exists
  | successor n ih =>
    let ⟨⟨m, r⟩, ⟨(h_exists : n = m * q + r), (h_less_than : r < q)⟩⟩ := ih
    show ∃ p, let ⟨m, r⟩ := p; successor n = m * q + r ∧ r < q
    have : successor r = q ∨ successor r < q := 
      (Or.commutative.mp ∘ less_than_or_equal_of_less_equal ∘ successor_less_equal_of_less_than) h_less_than
    cases this with
    | inl h_equal => 
      apply Exists.intro ⟨successor m, 0⟩
      apply And.intro
      . calc
          successor n = successor (m * q + r)         := congrArg successor h_exists
          _           = m * q + successor r           := (add_successor (m * q) r).symm
          _           = m * successor r + successor r := congrArg (m * . + successor r) h_equal.symm
          _           = successor m * successor r     := (successor_multiply m (successor r)).symm
          _           = successor m * q               := congrArg (successor m * .) h_equal
          _           = successor m * q + 0           := (add_zero (successor m * q)).symm
      . exact zero_less_than_positive q_positive
    | inr h_less_than =>
      apply Exists.intro ⟨m, successor r⟩
      apply And.intro
      . calc
          successor n = successor (m * q + r) := congrArg successor h_exists
          _ = m * q + successor r := (add_successor (m * q) r).symm
      . exact h_less_than
#+end_src

#+begin_src lean4
def power (m : ℕ) : ℕ → ℕ
| 0 => 1
| successor n => (power m n) * m

instance : Pow Natural Natural where
  pow := power
#+end_src

** Integer
:PROPERTIES:
:header-args: :tangle Barb/Data/Integer.lean
:END:

#+begin_src lean4
import Barb.Algebra
import Barb.Data.Natural
import Barb.Data.Option
import Barb.Function
import Barb.Logic
import Barb.Quotient
import Barb.Syntax

open Natural (zero successor)
#+end_src

*** Definition

It's worth saying a little bit about sensible constructions of the
integers. When I started thinking about this, my first guess was
something like this.

#+begin_src lean4 :tangle no
inductive Integer where
  | zero : Integer
  | successor : Integer → Integer
  | predecessor : Integer → Integer
#+end_src

This is wrong: we would have the problem that $P(zero)$
and $P(P(S(zero)))$ would be unequal canonical elements of ~Integer~,
which would be super bad; we only want one canonical element
representing $-1$ or any other integer. Thinking a bit longer,
something like this construction presents itself to you.

#+begin_src lean4 :tangle no
inductive Integer where
  | nonnegative : Natural → Integer
  | negative : Natural → Integer
#+end_src

The first constructor represents the positive integers and zero,
and the second constructor we can think of as $-1$ minus some natural
number. This is fine, and it's actually what mathlib does, but there are
some drawbacks. First, every operation and theorem is now a proof by
cases, which just kind of sucks. Second, are these really the integers
that God intended? The answer is no, they feel like the integers
merged in prematurely by the software development team to get the MVP
working before the spring is over.

We want a number system which is closed under a notion of
subtraction. In a very real sense, the integers /are/ this subtraction
operation on the natural numbers. Whatever notion of subtraction we
come up with, when $a - b = c - d$, it had better be the case that
$a + d = c + b$. Actually, we can take this to be the defining
property for subtraction. What we can do is start with the
space $\mathbb{N} \times \mathbb{N}$, create an equivalence relation
$(a, b) \sim (c, d) := a + d = c + b$ on this space, and then /define/ the
integers to be the quotient space of $\mathbb{N} \times \mathbb{N}$
with respect to the $\sim$ relation. Let's do it.

#+begin_src lean4
def IntegerEquivalent : (ℕ × ℕ) → (ℕ × ℕ) → Prop
  | (n, m), (k, l) => n + l = k + m
#+end_src

To be able to take the quotient space, we need to show that ~IntegerEquivalent~
is an equivalence relation.

#+begin_src lean4
theorem IntegerEquivalent.reflexive : Relation.Reflexive IntegerEquivalent :=
  λ _ => rfl

theorem IntegerEquivalent.symmetric : Relation.Symmetric IntegerEquivalent := Eq.symm

theorem IntegerEquivalent.transitive : Relation.Transitive IntegerEquivalent
  | (n, m), (k, l), (p, q), (h₁ : n + l = k + m), (h₂ : k + q = p + l) => by
    apply Natural.add_left_cancel (n := k + l)
    calc
      (k + l) + (n + q) = (n + l) + (k + q) := by simp [Natural.add_associative, Natural.add_commutative, Natural.add_left_commutative]
      _ = (k + m) + (p + l) := by simp [h₁, h₂]
      _ = (k + l) + (p + m) := by simp [Natural.add_associative, Natural.add_commutative, Natural.add_left_commutative]
#+end_src

Now we perform some nonsense to get Lean type classes to cooperate
with us, including showing that $(\mathbb{N}, \sim)$ forms a setoid,
and getting decidable equality for integers to work. I mean, this last
part is cool: if the defining relation for the quotient space is
decidable, then equality on the quotient space is also decidable
automatically, since that's what it means for two elements to be equal
in the space.

However, if you can't tell, I'm not a big fan of type
classes in general. I've been burned by the orphan rules for Rust
trait coherence, and I'm convinced that there's gotta be a better way
to do polymorphism in typed programming languages. (Functors to the
rescue? I don't know, I have to learn some category theory first).

#+begin_src lean4
theorem IntegerEquivalent.is_equivalence : Equivalence IntegerEquivalent :=
  { refl := IntegerEquivalent.reflexive, symm := IntegerEquivalent.symmetric, trans := IntegerEquivalent.transitive }

instance instanceHasEquivIntegerEquivalent : HasEquiv (ℕ × ℕ) where
  Equiv := IntegerEquivalent

instance instanceSetoidIntegerEquivalent : Setoid (ℕ × ℕ) where
  r := IntegerEquivalent
  iseqv := IntegerEquivalent.is_equivalence

theorem IntegerEquivalent.definition : (a ≈ b) = IntegerEquivalent a b := rfl

instance decideIntegerEquivalent (a b : ℕ × ℕ) : Decidable (a ≈ b) :=
  let (n, m) := a
  let (k, l) := b
  Natural.decideEqual (n + l) (k + m)

instance decideIntegerEquivalentQuotientEqual : DecidableEq (Quotient instanceSetoidIntegerEquivalent) := inferInstance

-- This is basically the one line of consequence in this block
def Integer := Quotient instanceSetoidIntegerEquivalent

namespace Integer

notation "ℤ" => Integer

instance decideEqual : DecidableEq Integer := decideIntegerEquivalentQuotientEqual

instance : OfNat Integer n where
  ofNat := ⟦(Natural.fromNat n, 0)⟧

instance Zero : Integer := ⟦(0, 0)⟧

instance One : Integer := ⟦(1, 0)⟧
#+end_src

In retrospect, I'm glad I took this route. I got stuck several times
using this definition and I learned a lot working through the details
of ~Quotient~ in Lean.

*** Operations

Here we define negation, addition, and multiplication, and we use the
first two to define subtraction. We will show that these satisfy a
collection of properties which, taken together, show that the integers
form a ~CommutativeRing~.

Just like the natural numbers, we define each primitive operation
recursively. However, since we defined the integers with a quotient
type, things will work a little differently this time. To define an operation
inductively, we define an operation on the underlying space and then
"lift" this operation to the quotient space. Remember though, each
element of the quotient space is actually an equivalence class, and
importantly, this class could consist of /multiple/ elements of the
original space. Thus, to make sure that lifting this operation makes
sense, we need to show that the result of the operation is independent
of our choice of representative. Logically, for an operation
$f : \alpha \to \beta$ and a relation
$\sim : \alpha \to \alpha \to \text{Prop}$, this amounts to showing:

$$
\forall a', a'' : \alpha, [a']_{\sim} = [a'']_{\sim} \to f(a') = f(a'')
$$

This simplifies to:

$$
a' \sim a'' \to f(a') = f(a'')
$$

Notice, the outputs $f(a')$ and $f(a'')$ are /equal/, not just related
by $\sim$. I was confused by this in my first encounter. Proving this
property is usually referred to as showing that $f$ "respects" the
relation $\sim$, or that $f$ is "well-defined". This second one is kind
of weird, because we can't really even define $f$ without showing that
this property holds, but regardless, this is very common language from
what I can tell.

To negate an integer $a = [(n, m)] : \mathbb{Z}$, we flip it's
positive and negative components.

#+begin_src lean4
def negate : ℤ → ℤ :=
  let negate' := λ ((n, m) : ℕ × ℕ) => (m, n)
  Quotient.map negate' <| by
  intro (n, m) (n', m') (h : n + m' = n' + m)
  show m + n' = m' + n
  simp [Natural.add_commutative, h]

instance : Neg Integer where
  neg := negate

@[simp] theorem negate_definition : negate a = -a := rfl
#+end_src

Addition of two integers $a = [(n, m)], b = [(k, l)] : \mathbb{Z}$ is
defined by $a + b := [(n + k, m + l)]$.

#+begin_src lean4
def add : ℤ → ℤ → ℤ :=
  let add' := λ ((n, m) : ℕ × ℕ) ((k, l) : ℕ × ℕ) => (n + k, m + l)
  Quotient.map₂ add' <| by
  intro (n, m) (n', m') (h₁ : n + m' = n' + m)
  intro (k, l) (k', l') (h₂ : k + l' = k' + l)
  show (n + k) + (m' + l') = (n' + k') + (m + l)
  calc
    (n + k) + (m' + l')
      = (n + m') + (k + l') := by simp [Natural.add_associative, Natural.add_commutative, Natural.add_left_commutative]
    _ = (n' + m) + (k + l') := congrArg (. + _) h₁
    _ = (n' + m) + (k' + l) := congrArg (_ + .) h₂
    _ = (n' + k') + (m + l) := by simp [Natural.add_associative, Natural.add_commutative, Natural.add_left_commutative]

instance : Add Integer where add := add

@[simp] theorem add_definition : add a b = a + b := rfl
#+end_src

Multiplication is given by
$(a, b) \times (c, d) := [(ac + bd, ad + bc)]$, which is just FOIL
from grade school. The proof that ~multiply'~ is well-defined is
pretty painful, but I couldn't get the simplifier to do any better.

#+begin_src lean4
def multiply : ℤ → ℤ → ℤ :=
  let multiply' := λ ((n, m) : ℕ × ℕ) ((k, l) : ℕ × ℕ) => (n * k + m * l, n * l + m * k)
  Quotient.map₂ multiply' <| by
  intro (n, m) (n', m') (h₁ : n + m' = n' + m)
  intro (k, l) (k', l') (h₂ : k + l' = k' + l)
  apply Natural.add_left_cancel (n := (n * l + m * k) + (n' * k + m' * l))
  have h₃ : (n * k + m * l) + (n' * l + m' * k) = (n * l + m * k) + (n' * k + m' * l) := calc
    (n * k + m * l) + (n' * l + m' * k)
      = (n + m') * k + (n' + m) * l := by simp [Natural.add_associative, Natural.add_commutative, Natural.add_left_commutative, Natural.right_distributive]
    _ = (n' + m) * k + (n + m') * l := by simp [h₁]
    _ = (n * l + m * k) + (n' * k + m' * l) := by simp [Natural.add_associative, Natural.add_commutative, Natural.add_left_commutative, Natural.right_distributive]
  calc
    ((n * l + m * k) + (n' * k + m' * l)) + ((n * k + m * l) + (n' * l' + m' * k'))
      = (n * l + m * k) + ((n * k + m * l) + (n' * (k + l') + m' * (k' + l))) :=
        by simp [Natural.add_associative, Natural.add_commutative, Natural.left_distributive, Natural.add_left_commutative]
    _ = (n * l + m * k) + ((n * k + m * l) + (n' * (k' + l) + m' * (k + l'))) := by simp [h₂]
    _ = ((n * k + m * l) + (n' * l + m' * k)) + ((n' * k' + m' * l') + (n * l + m * k)) :=
        by simp [Natural.add_associative, Natural.add_commutative, Natural.left_distributive, Natural.add_left_commutative]
    _ = ((n * l + m * k) + (n' * k + m' * l)) + ((n' * k' + m' * l') + (n * l + m * k)) := congrArg (. + _) h₃

instance : Mul Integer where mul := multiply

@[simp] theorem multiply_definition : multiply a b = a * b := rfl
#+end_src

Now let's demonstrate those properties we talked about. Most of these
are relatively painless -- except for ~multiply_associative~, which is
verbose for the same reasons as the definition of multiplication. For
every statement, we do an induction on each of the integers
involved. This lowers to proving statements about the natural numbers,
so we can just appeal to the algebra we developed for them.

#+begin_src lean4
theorem add_commutative : ∀ (a b : ℤ), a + b = b + a := by
  apply Quotient.ind₂
  intro (n, m) (k, l)
  apply Quotient.sound
  show (n + k) + (l + m) = (k + n) + (m + l)
  simp [Natural.add_commutative]

theorem add_associative : ∀ (a b c : ℤ), (a + b) + c = a + (b + c) := by
  apply Quotient.ind₃
  intro (n, m) (k, l) (o, p)
  apply Quotient.sound
  show ((n + k) + o) + (m + (l + p)) = (n + (k + o)) + ((m + l) + p)
  simp [Natural.add_associative]

theorem add_zero : ∀ (a : ℤ), a + 0 = a := by
  apply Quotient.ind
  intro (n, m)
  apply Quotient.sound
  show (n + 0) + m = n + (m + 0)
  simp [Natural.add_zero]

theorem add_inverse : ∀ (a : ℤ), a + (-a) = 0 := by
  apply Quotient.ind
  intro (n, m)
  apply Quotient.sound
  show (n + m) + 0 = 0 + (m + n)
  simp [Natural.add_zero, Natural.zero_add, Natural.add_commutative]

theorem multiply_commutative : ∀ (a b : ℤ), a * b = b * a := by
  apply Quotient.ind₂
  intro (n, m) (k, l)
  apply Quotient.sound
  show (n * k + m * l) + (k * m + l * n) = (k * n + l * m) + (n * l + m * k)
  simp [Natural.add_commutative, Natural.multiply_commutative]

theorem multiply_associative : ∀ (a b c : ℤ), (a * b) * c = a * (b * c) := by
  intro a b c
  let i := Quotient.mk instanceSetoidIntegerEquivalent
  suffices ∀ (a b c : ℕ × ℕ), multiply (multiply (i a) (i b)) (i c) = multiply (i a) (multiply (i b) (i c))
  from Quotient.inductionOn₃ a b c this
  intro (n, m) (k, l) (p, q)
  apply Quotient.sound
  show ((n*k + m*l)*p + (n*l + m*k)*q) + (n*(k*q + l*p) + m*(k*p + l*q))
    = (n*(k*p + l*q) + m*(k*q + l*p)) + ((n*k + m*l)*q + (n*l + m*k)*p)
  let d := (n*k + m*l)*p + (n*l + m*k)*q
  let f := n*(k*p + l*q) + m*(k*q + l*p)
  let e := n*(k*q + l*p) + m*(k*p + l*q)
  let g := (n*k + m*l)*q + (n*l + m*k)*p
  have r {u v w x y z : ℕ} : (u*w + v*x)*y + (u*x + v*w)*z = u*(w*y + x*z) + v*(w*z + x*y) := calc
    (u*w + v*x)*y + (u*x + v*w)*z = u*w*y + v*x*y + u*x*z + v*w*z := by simp [Natural.add_associative, Natural.right_distributive]
    _ = u*(w*y) + u*(x*z) + v*(w*z) + v*(x*y) := by simp [Natural.add_associative, Natural.add_commutative, Natural.add_left_commutative, Natural.multiply_associative]
    _ = u*(w*y + x*z) + v*(w*z + x*y) := by simp [Natural.left_distributive, Natural.add_associative]
  have hdf : d = f := calc
    d = (n*k + m*l)*p + (n*l + m*k)*q := rfl
    _ = n*(k*p + l*q) + m*(k*q + l*p) := r
    _ = f := rfl
  have heg : e = g := calc
    e = n*(k*q + l*p) + m*(k*p + l*q) := rfl
    _ = (n*k + m*l)*q + (n*l + m*k)*p := r.symm
    _ = g := rfl
  simp [hdf, heg]

theorem multiply_one : ∀ (a : ℤ), a * 1 = a := by
  apply Quotient.ind
  intro (n, m)
  apply Quotient.sound
  show (n * 1 + m * 0) + m = n + (n * 0 + m * 1)
  simp [Natural.add_associative, Natural.zero_add, Natural.multiply_one, Natural.multiply_zero]

theorem left_distributive : ∀ (a b c : ℤ), a * (b + c) = a * b + a * c := by
  apply Quotient.ind₃
  intro (n, m) (k, l) (p, q)
  apply Quotient.sound
  show (n*(k + p) + m*(l + q)) + ((n*l + m*k) + (n*q + m*p)) = ((n*k + m*l) + (n*p + m*q)) + (n*(l + q) + m*(k + p))
  simp [Natural.left_distributive, Natural.add_associative, Natural.add_commutative, Natural.add_left_commutative]

theorem right_distributive : ∀ (a b c : ℤ), (a + b) * c = a * c + b * c := by
  intro a b c
  rw [multiply_commutative, left_distributive, multiply_commutative c a, multiply_commutative c b]
#+end_src

Collectively, these properties define an algebraic structure called a
_commutative ring_. The integers are like the poster child for commutative rings.

#+begin_src lean4
instance commutativeRing : CommutativeRing Integer where
  add_commutative := add_commutative
  add_associative := add_associative
  add_zero := add_zero
  add_inverse := add_inverse

  multiply_commutative := multiply_commutative
  multiply_associative := multiply_associative
  multiply_one := multiply_one

  left_distributive := left_distributive
  right_distributive := right_distributive
#+end_src

*** Operation lemmas

Now we get to a more unpleasant section. We've got to prove a whole
bunch of lemmas that we'll need later, but which -- with only a few
exceptions -- refer exclusively to the ring properties we just
proved. I mean these are all pratically begging to be generalized to
their common algebraic structure. I'll complain about this more in the
rational module later.

#+begin_src lean4
theorem zero_add (a : ℤ) : 0 + a = a := by
  rw [add_commutative, add_zero]

theorem add_left_commutative (n m k : ℤ) : n + (m + k) = m + (n + k) := by
  rw [← add_associative, add_commutative n m, add_associative]

theorem add_right_commutative (n m k : ℤ) : (n + m) + k = (n + k) + m := by
  rw [add_associative, add_commutative m k, ← add_associative]

theorem add_inverse_left (a : ℤ) : -a + a = 0 := by
  rw [add_commutative, add_inverse]

theorem add_left_cancel {a b c : ℤ} (h : a + b = a + c) : b = c := by
  have : -a + (a + b) = -a + (a + c) := by rw [h]
  simp [← add_associative, add_inverse_left, zero_add] at this
  exact this

theorem add_right_cancel {a b c : ℤ} (h : a + c = b + c) : a = b := by
  rewrite [add_commutative a c, add_commutative b c] at h
  exact add_left_cancel h

theorem negate_add_cancel_left (a b : ℤ) : -a + (a + b) = b := by
  rw [← add_associative (-a) a b, add_inverse_left, zero_add]

theorem negate_add_cancel_right (a b : ℤ) : (a + -b) + b = a := by
  rw [add_associative, add_inverse_left, add_zero]

theorem add_negate_cancel_left (a b : ℤ) : a + (-a + b) = b := by
  rw [← add_associative, add_inverse, zero_add]

theorem add_negate_cancel_right (a b : ℤ) : (a + b) + -b = a := by
  rw [add_associative, add_inverse, add_zero]
#+end_src

Okay first question: notice that ~multiply_zero~ has to refer to the
structural properties of integers again. Does this only hold for some
rings? If so, is that like an important classification or distinction
in ring theory? Can't wait to find out.

#+begin_src lean4
theorem multiply_zero : ∀ (a : ℤ), a * 0 = 0 := by
  apply Quotient.ind
  intro (n, m)
  apply Quotient.sound
  show (n*0 + m*0) + 0 = 0 + (n*0 + m*0)
  simp [Natural.add_zero, Natural.multiply_zero]

theorem zero_multiply (a : ℤ) : 0 * a = 0 := by
  rw [multiply_commutative, multiply_zero]

theorem one_multiply (a : ℤ) : 1 * a = a := by
  rw [multiply_commutative, multiply_one]
#+end_src

See, I think even the subtraction operation could be generalized to
the ring structure, so you could just get the operation and all the
lemmas for free once you show that the integers form a ring.

#+begin_src lean4
def subtract (a b : ℤ) : ℤ := a + (-b)

instance : Sub Integer where sub := subtract

theorem subtract_definition (a b : ℤ) : a + (-b) = a - b := rfl

theorem negate_zero : (0 : ℤ) = (-0 : ℤ) := rfl

theorem negate_involutive : Function.Involutive negate := by
  apply Quotient.ind
  intro (n, m)
  rfl

@[simp]
theorem negate_negate : ∀ a : ℤ, - -a = a := λ a => negate_involutive a

theorem subtract_self (a : ℤ) : a - a = 0 := add_inverse a

theorem subtract_zero (a : ℤ) : a - 0 = a := by
  rw [← subtract_definition, ← negate_zero, add_zero]

theorem zero_subtract (a : ℤ) : 0 - a = -a := by
  rw [← subtract_definition, zero_add]

theorem negate_equal_of_add_equal_zero {a b : ℤ} (h : a + b = 0) : a = -b := by
  rw [← add_zero a, ← add_inverse (b), ← add_associative, h, zero_add]

theorem subtract_equal_zero_of_equal {a b : ℤ} (h : a = b) : a - b = 0 := by
  rw [← h, subtract_self]

theorem equal_of_subtract_equal_zero {a b : ℤ} (h : a - b = 0) : a = b := by
  rw [← add_zero a, ← add_inverse b, add_commutative b, ← add_associative, subtract_definition, h, zero_add]

theorem negate_add (a b : ℤ) : -(a + b) = -a + -b := by
  apply add_left_cancel (a := a + b)
  rw [add_inverse, add_associative, ← add_associative b (-a) (-b), add_commutative b (-a),
     ← add_associative a, ← add_associative, add_inverse, zero_add, add_inverse]

theorem subtract_subtract (a b c : ℤ) : (a - b) - c = a - (b + c) := by
  apply Eq.symm
  rw [← subtract_definition, negate_add, ← add_associative, subtract_definition, subtract_definition]

theorem negate_subtract {a b : ℤ} : -(a - b) = b - a := by
  rw [← subtract_definition, negate_add, negate_negate, add_commutative, subtract_definition]

theorem subtract_subtract_self (a b : ℤ) : a - (a - b) = b := by
  rw [← subtract_definition, negate_subtract, ← subtract_definition,
    add_commutative (b) (-a), add_negate_cancel_left]
#+end_src

For ~negate_multiply_equal_negate_multiply~, I actually did look at
the proof of the corresponding theorem in mathlib the first one I came
up with was way more complicated then I felt like it needed to be. The
shorter version is kind of sneaky. You rewrite $(-a)b = -(ab)$ to
$(-a)b + ab = 0$ by adding $-(ab)$ to both sides, then
distribute to $(-a + a)b = 0$ which gives $0 = 0$.

#+begin_src lean4
theorem negate_multiply_equal_negate_multiply (a b : ℤ) : -(a * b) = -a * b := by
  apply Eq.symm
  apply negate_equal_of_add_equal_zero
  rw [← right_distributive, add_commutative, add_inverse, zero_multiply]

theorem negate_multiply_equal_multiply_negate (a b : ℤ) : -(a * b) = a * -b := by
  rw [multiply_commutative, negate_multiply_equal_negate_multiply, multiply_commutative]
#+end_src

#+begin_src lean4
theorem subtract_multiply (a b c : ℤ) : (a - b) * c = a * c - b * c := by
  rw [← subtract_definition, right_distributive, ← negate_multiply_equal_negate_multiply, subtract_definition]

theorem multiply_subtract (a b c : ℤ) : a * (b - c) = a * b - a * c := by
  rw [multiply_commutative a _, subtract_multiply, multiply_commutative b a, multiply_commutative a c]
#+end_src

Now, I'm inclined to think that $ab = 0 \to a = 0 \lor b = 0$ holds
for all rings, and if so, I can't wait to try proving this, because my
current proof for this statement over the integers makes a super ugly
appeal to order trichotomy, and I can't figure out a better way.

#+begin_src lean4
theorem equal_of_unlift_equal_zero {n m : ℕ} : ⟦(n, m)⟧ = (0 : ℤ) → n = m := by
  intro h
  rw [← Natural.add_zero n, ← Natural.zero_add m]
  exact Quotient.exact h

theorem equal_zero_of_lift_equal {n m : ℕ} : n = m → ⟦(n, m)⟧ = (0 : ℤ) := by
  intro h
  rw [← Natural.add_zero n, ← Natural.zero_add m] at h
  exact Quotient.sound h

theorem equal_zero_of_multiply_equal_zero : ∀ {a b : ℤ}, a * b = 0 → a = 0 ∨ b = 0 := by
  apply Quotient.ind₂
  intro (n, m) (k, l) h'
  have h := equal_of_unlift_equal_zero h'
  apply Or.implies equal_zero_of_lift_equal equal_zero_of_lift_equal
  have f {w x y z : ℕ} (h_less : w < x) (h_equivalent : w*y + x*z = w*z + x*y) : y = z := by
  { let ⟨a, h_positive, (h_exists : w + a = x)⟩ := Natural.equal_add_positive_of_less_than h_less
    apply (Natural.multiply_left_cancel . h_positive)
    apply Natural.add_left_cancel (n := w*y + w*z)
    rw [← h_exists, Natural.right_distributive, ← Natural.add_associative, Natural.right_distributive,
      Natural.add_left_commutative, ← Natural.add_associative] at h_equivalent
    exact h_equivalent.symm }
  match less_than_trichotomous n m with
  | Or.inl h_less => exact Or.inr (f h_less h)
  | Or.inr (Or.inl h_equal) =>
    apply Or.inl
    simp [h_equal, Natural.add_zero, Natural.zero_add]
  | Or.inr (Or.inr h_greater) =>
    apply Or.inr
    rw [Natural.add_commutative (n*l) (m*k), Natural.add_commutative (n*k) (m*l)] at h
    exact f h_greater h.symm

theorem multiply_equal_zero_of_equal_zero : ∀ {a b : ℤ}, a = 0 ∨ b = 0 → a * b = 0 := by
  apply Quotient.ind₂
  intro (n, m) (k, l) h'
  have h := Or.implies equal_of_unlift_equal_zero equal_of_unlift_equal_zero h'
  rw [← multiply_definition]
  simp [multiply, Quotient.map₂]
  apply equal_zero_of_lift_equal
  match h with
  | Or.inl hnm => rw [hnm, Natural.add_commutative]
  | Or.inr hkl => rw [hkl]
#+end_src

#+begin_src lean4
theorem multiply_left_commutative (n m k : ℤ) : n * (m * k) = m * (n * k) := by
  rw [← multiply_associative, multiply_commutative n m, multiply_associative]

theorem multiply_right_commutative (n m k : ℤ) : (n * m) * k = (n * k) * m := by
  rw [multiply_associative, multiply_commutative m k, ← multiply_associative]

theorem multiply_left_cancel {a b c : ℤ} (h : a * b = a * c) (a_nonzero : a ≠ 0) : b = c := by
  suffices c - b = 0 from (equal_of_subtract_equal_zero this).symm
  apply (Or.resolve_left . a_nonzero)
  apply equal_zero_of_multiply_equal_zero
  rw [← subtract_definition, left_distributive, ← h,
    ← negate_multiply_equal_multiply_negate, add_inverse]

theorem multiply_right_cancel {a b c : ℤ} (h : a * c = b * c) (c_nonzero : c ≠ 0) : a = b := by
  apply multiply_left_cancel (a := c)
  rw [multiply_commutative c a, multiply_commutative c b]
  exact h
  exact c_nonzero

theorem multiply_nonzero_of_nonzero {a b : ℤ} (ha : a ≠ 0) (hb : b ≠ 0) : a * b ≠ 0 := by
  intro h
  apply hb
  apply (Integer.multiply_left_cancel (a := a) . ha)
  rw [h, multiply_zero]

theorem nonzero_of_multiply_nonzero {a b : ℤ} (h : a * b ≠ 0) : a ≠ 0 ∧ b ≠ 0 :=
  not_or.mp (mt multiply_equal_zero_of_equal_zero h)
#+end_src

*** Order

To define the $\le$ relation on the integers, we kind of just cop out
and repeat our definition from the natural numbers. Actually, I don't
know how else you'd define it, but anyway, we don't have a notion of
heterogeneous addition between integers and natural numbers, and I
don't really want to develop one, since that would involve making an
API (collection of lemmas) for it. Further, this isn't set theory, so
we don't just get to pretend that $\mathbb{N} \subset \mathbb{Z}$ and
avoid this issue. (By the way, I'm still skeptical about how exactly
this is true in set theory, but I haven't read any Cantor so I'll
susped judgement.)

Instead, we need to define a conversion operator from natural numbers
to nonnegative integers. Unfortunately, we need the $\le$ relation to
be defined before we even have the language to claim that this
conversion has good properties, so we delay this until after we define
$\le$ and show that it forms a total order.

#+begin_src lean4
def ofNatural (n : ℕ) : ℤ :=
  Quotient.mk instanceSetoidIntegerEquivalent (n, 0)

instance : Coe Natural Integer := ⟨ofNatural⟩

theorem ofNatural_add (n m : ℕ) : ofNatural (n + m) = ofNatural n + ofNatural m := rfl

theorem ofNatural_multiply (n m : ℕ) : ofNatural (n * m) = ofNatural n * ofNatural m := by
  unfold ofNatural
  apply Quotient.sound
  show (n * m) + (n * 0 + 0 * m) = (n * m + 0 * 0) + 0
  simp [Natural.add_zero, Natural.zero_add, Natural.multiply_zero, Natural.zero_multiply]

theorem ofNatural_injective : Function.Injective ofNatural := by
  intro a b h
  rw [← Natural.add_zero a, Quotient.exact h, Natural.add_zero]

theorem ofNatural_zero : ofNatural 0 = (0 : ℤ) := rfl
#+end_src

#+begin_src lean4
def LessEqual (a b : ℤ) : Prop := ∃ (n : ℕ), a + ↑n = b

instance : LE Integer where
  le := LessEqual

theorem less_equal_definition : (a ≤ b) = LessEqual a b := rfl
#+end_src

The proofs that $\le$ forms a partial order are essentially the exact
same arguments made for the natural number version.

#+begin_src lean4
theorem LessEqual.reflexive : Relation.Reflexive LessEqual :=
  λ _ => Exists.intro 0 (add_zero _)

theorem LessEqual.antisymmetric : Relation.AntiSymmetric LessEqual := by
  intro a b ⟨n, hn⟩ ⟨m, hm⟩
  suffices m = 0 ∧ n = 0
  by rw [← add_zero a, ← ofNatural_zero, ← this.right, hn]
  apply Natural.equal_zero_of_add_equal_zero
  apply ofNatural_injective
  apply add_left_cancel (a := b)
  rw [ofNatural_add, ← add_associative, hm, hn, ofNatural_zero, add_zero]

theorem LessEqual.transitive : Relation.Transitive LessEqual := by
  intro a b c ⟨n, (ha : a + ↑n = b)⟩ ⟨m, (hb : b + ↑m = c)⟩
  apply Exists.intro ↑(n + m)
  rw [ofNatural_add, ← add_associative, ha, hb]
#+end_src

It took a little bit to figure out how to show that $\le$ on the
integers was decidable. The trickiest part was just understanding the
rules for what can and can't be done with ~Quotient~ types. The key is
to apply the same technique I mentioned when discussing decidability
in the natural numbers module: find something you know how to compute
and prove that it's logically equivalent to the proposition you want
to decide (now you get the idea that I might have gone back and
written that portion retrospectively).

For the integer $\le$, this ammounts to two insights. First, that we have the
logical equivalence $a \le b \iff 0 \le b - a$
[cite:@tao2022analysis, Lemma 4.1.11 (a), p. 82], and second, that an
integer $a = [(n, m)]$ is nonnegative if and only if $m \le n$. We
have a decision procedure for $\le$ on the natural numbers, so given
$a, b : \mathbb{Z}$, we calculate $b - a$, lower this value to natural
numbers $n, m : \mathbb{N}$, decide whether $m \le n$, and then use
the properties we developed to show that this suffices to decide $\le$
over the integers.

#+begin_src lean4
theorem less_equal_of_subtract_nonnegative {a b : ℤ} : 0 ≤ b - a → a ≤ b := by
  intro ⟨n, (h : 0 + ↑n = b - a)⟩
  apply Exists.intro n
  rw [add_commutative a ↑n, ← zero_add (↑n + a), ← add_associative, h,
    ← subtract_definition, add_associative, add_inverse_left, add_zero]

theorem subtract_nonnegative_of_less_equal {a b : ℤ} : a ≤ b → 0 ≤ b - a := by
  intro ⟨n, (h : a + ↑n = b)⟩
  apply Exists.intro n
  rw [← add_inverse a, add_right_commutative, h, subtract_definition]

theorem nonnegative_of_negative_less_equal_positive {n m : ℕ} : m ≤ n → (0 : ℤ) ≤ ⟦(n, m)⟧ := by
  intro ⟨a, (ha : m + a = n)⟩
  apply Exists.intro a
  apply Quotient.sound
  show (0 + a) + m = n + 0
  simp [Natural.add_zero, Natural.add_commutative, ha]

theorem negative_less_equal_positive_of_nonnegative {n m : ℕ} : (0 : ℤ) ≤ ⟦(n, m)⟧ → m ≤ n := by
  intro ⟨a, (ha : (0 : ℤ) + ↑a = ⟦(n, m)⟧)⟩
  have : (0 + a) + m = n + (0 + 0) := Quotient.exact ha
  simp [Natural.zero_add, Natural.add_commutative] at this
  exact (Exists.intro a this)

instance decideNonNegative (a : ℤ) : Decidable (0 ≤ a) :=
  Quotient.recOnSubsingleton a
  λ ((n, m) : ℕ × ℕ) =>
  if h : m ≤ n then
    isTrue (nonnegative_of_negative_less_equal_positive h)
  else
    isFalse (mt negative_less_equal_positive_of_nonnegative h)

instance decideLessEqual (a b : ℤ) : Decidable (a ≤ b) :=
  if h : 0 ≤ b - a then
    isTrue (less_equal_of_subtract_nonnegative h)
  else
    isFalse (mt subtract_nonnegative_of_less_equal h)
#+end_src

To show that $\le$ is strongly connected, we make a
super lame appeal to this property for $\le$ over the natural,
which itself was a lame appeal to decidability using a double
induction. It's probably worth looking at other people's proofs of
these two.

#+begin_src lean4
theorem LessEqual.strongly_connected : Relation.StronglyConnected LessEqual :=
  have lift_less_equal {n m k l : ℕ} : n + l ≤ k + m → LessEqual ⟦(n, m)⟧ ⟦(k, l)⟧ := by
  { intro ⟨a, (ha : (n + l) + a = k + m)⟩
    apply Exists.intro a
    apply Quotient.sound
    simp
    show (n + a) + l = k + m
    rw [Natural.add_right_commutative, ha] }
  Quotient.ind₂ λ (p, q) (s, t) =>
  Or.implies lift_less_equal lift_less_equal (Natural.LessEqual.strongly_connected (p + t) (s + q))
#+end_src

All of this shows that $\le$ forms a total order for $\mathbb{Z}$.

#+begin_src lean4
instance totalOrder : DecidableTotalOrder Integer where
  less_equal_reflexive := LessEqual.reflexive
  less_equal_antisymmetric := LessEqual.antisymmetric
  less_equal_transitive := LessEqual.transitive
  less_equal_strongly_connected := LessEqual.strongly_connected
  decideEqual := decideEqual
  decideLessEqual := decideLessEqual
#+end_src

TODO: Write a good explanation. Start from the very
beginning. Explain what it would look like if we had proof
relevance. Then explain the approach you want to take instead. Explain
why it was so hard, explain the problem with Quotient.rec

#+begin_src lean4
theorem ofNatural_nonnegative (n : ℕ) : (0 : ℤ) ≤ ↑n :=
  Exists.intro n (zero_add n)
  
theorem ofNatural_successor_positive (n : ℕ) : (0 : ℤ) < ↑(successor n) := by
  match equal_or_less_than_of_less_equal (ofNatural_nonnegative (successor n)) with
  | Or.inl h =>
    have : 0 + 0 = successor n + 0 := Quotient.exact h
    simp [add_zero] at this
    exact absurd this.symm (Natural.successor_not_equal_zero n)
  | Or.inr h =>
    exact h

theorem equal_ofNatural_of_nonnegative : ∀ {a : ℤ}, 0 ≤ a → ∃ n : ℕ, ↑n = a := by
  apply Quotient.ind
  intro (n, m) ⟨a, ha⟩
  simp [zero_add] at ha
  exact Exists.intro a ha
#+end_src

#+begin_src lean4
abbrev NonNegativeInteger := {a : ℤ // 0 ≤ a}
abbrev PositiveInteger := {a : ℤ // 0 < a}
abbrev NonZeroInteger := {a : ℤ // a ≠ 0}
abbrev NegativeInteger := {a : ℤ // a < 0}
abbrev NonPositiveInteger := {a : ℤ // a ≤ 0}
#+end_src

#+begin_src lean4
namespace NonNegativeInteger

def preToNatural' : ℕ × ℕ → Option ℕ
  | (n, m) => if n ≥ m then some (Natural.distance n m) else none

@[simp]
theorem preToNatural_none (x : ℕ × ℕ) (h : x.1 < x.2) : preToNatural' x = none := by
  have := not_less_equal_of_greater_than h
  simp [preToNatural', not_less_equal_of_greater_than h]

@[simp]
theorem preToNatural_some (x : ℕ × ℕ) (h : x.1 ≥ x.2) : preToNatural' x = some (Natural.distance x.1 x.2) := by
  simp [preToNatural', h]

def toNatural' : ℤ → Option ℕ :=
  Quotient.lift preToNatural' <| by
  intro (n, m) (k, l) (h : n + l = k + m)
  cases Decidable.em (m ≤ n)
  <;> cases Decidable.em (l ≤ k)
  <;> simp_all [preToNatural', preToNatural_none, preToNatural_some]
  case inl.inl hnm hkl =>
    rw [Natural.add_commutative k m] at h
    exact Natural.distance_equal_of_add_equal h
  case inl.inr hnm hkl =>
    rw [Natural.add_commutative k m] at h
    have := Natural.right_greater_equal_of_add_left_less_equal h.symm hnm
    exact absurd this hkl
  case inr.inl hnm hkl =>
    rw [Natural.add_commutative n l] at h
    have := Natural.right_greater_equal_of_add_left_less_equal h hkl
    exact absurd this hnm

def toNatural : NonNegativeInteger → ℕ
  | (⟨a, a_nonnegative⟩) =>
    Option.get (toNatural' a) <| by
    have ⟨n, hn⟩ := equal_ofNatural_of_nonnegative a_nonnegative
    rw [toNatural', ← hn, ofNatural, Quotient.lift_construct, preToNatural']
    simp [Natural.zero_less_equal, subtract_zero, ite_true, Option.isSome]

def fromNatural (n : ℕ) : NonNegativeInteger :=
  ⟨n, ofNatural_nonnegative n⟩

theorem fromNatural_toNatural_left_inverse : Function.LeftInverse toNatural fromNatural := by
  intro n
  simp [fromNatural, ofNatural, toNatural, toNatural', preToNatural', Natural.distance_zero_left]
  
theorem fromNatural_toNatural_right_inverse : Function.RightInverse toNatural fromNatural := by
  intro ⟨a, b, h⟩
  rw [zero_add, ofNatural] at h
  subst h
  simp [toNatural, toNatural', preToNatural', fromNatural, ofNatural, Natural.distance_zero_left]

end NonNegativeInteger
#+end_src

*** Order lemmas

Now we come to the huge collection of lemmas about ordering on the
integers. It's difficult to organize them all, so it's worth it to lay
out first what we expect to be true.

Or not, the latex crashed emacs and I didn't save. Not doing it again
right now.

#+begin_src lean4
theorem add_left_monotone (a : ℤ) : Monotone (a + .) := by
  intro b c h
  let ⟨n, hn⟩ := h
  apply Exists.intro n
  rw [add_associative, hn]

theorem add_right_monotone (c : ℤ) : Monotone (. + c) := by
  intro a b h
  simp
  rw [add_commutative a c, add_commutative b c]
  exact add_left_monotone c h

theorem less_equal_of_add_less_equal_left {a b c : ℤ} (h : a + b ≤ a + c) : b ≤ c := by
  have := add_left_monotone (-a) h
  simp [negate_add_cancel_left] at this
  exact this

theorem less_equal_of_add_less_equal_right {a b c : ℤ} (h : a + c ≤ b + c) : a ≤ b := by
  rw [add_commutative a c, add_commutative b c] at h
  exact less_equal_of_add_less_equal_left h

theorem add_less_equal_add {a b c d : ℤ} (hac : a ≤ c) (hbd : b ≤ d) : a + b ≤ c + d :=
  less_equal_transitive (add_right_monotone b hac) (add_left_monotone c hbd)

theorem less_equal_add_of_nonnegative_left {a b : ℤ} (h : 0 ≤ b) : a ≤ b + a := by
  have := add_less_equal_add h (less_equal_reflexive a)
  rw [zero_add] at this
  exact this

theorem less_equal_add_of_nonnegative_right {a b : ℤ} (h : 0 ≤ b) : a ≤ a + b := by
  rw [add_commutative a b]
  exact less_equal_add_of_nonnegative_left h
  
theorem less_equal_of_subtract_nonpositive {a b : ℤ} (h : a - b ≤ 0) : a ≤ b := by
  have := add_right_monotone b h
  simp [zero_add] at this
  rw [← subtract_definition, negate_add_cancel_right] at this
  exact this

theorem subtract_nonpositive_of_less_equal {a b : ℤ} (h : a ≤ b) : a - b ≤ 0 := by
  have := add_right_monotone (-b) h
  simp [add_inverse] at this
  exact this
  
theorem negate_antitone : Antitone negate := by
  intro a b h
  have ha := add_right_monotone (-a) h
  simp [add_inverse, add_commutative] at ha
  have hb := add_right_monotone (-b) ha
  simp [zero_add] at hb
  rw [add_right_commutative, add_inverse, zero_add] at hb
  exact hb

theorem less_equal_of_negate_less_equal_negate {a b : ℤ} (h : -b ≤ -a) : a ≤ b :=
  suffices - -a ≤ - -b by simp at this; exact this
  negate_antitone h
  
theorem multiply_nonnegative_left_monotone {a : ℤ} (ha : 0 ≤ a) : Monotone (a * .) := by
  intro b c h
  let ⟨n, hn⟩ := h
  let ⟨m, hm⟩ := ha
  rw [zero_add] at hm
  apply Exists.intro ↑(m * n)
  rw [ofNatural_multiply, hm, ← left_distributive, hn]
  
theorem multiply_nonnegative_right_monotone {c : ℤ} (hc : 0 ≤ c) : Monotone (. * c) := by
  unfold Monotone
  intro a b h
  simp
  rw [multiply_commutative a c, multiply_commutative b c]
  exact multiply_nonnegative_left_monotone hc h

theorem multiply_nonnegative {a b : ℤ} (ha : 0 ≤ a) (hb : 0 ≤ b) : 0 ≤ a * b := by
  let ⟨n, hn⟩ := equal_ofNatural_of_nonnegative ha
  let ⟨m, hm⟩ := equal_ofNatural_of_nonnegative hb
  apply Exists.intro ↑(n * m)
  rw [zero_add, ofNatural_multiply, hn, hm]
  
theorem multiply_nonpositive {a b : ℤ} (ha : a ≤ 0) (hb : b ≤ 0) : 0 ≤ a * b := by
  have := multiply_nonnegative (negate_antitone ha) (negate_antitone hb)
  rw [negate_definition, negate_definition, ← negate_multiply_equal_multiply_negate, ← negate_multiply_equal_negate_multiply, negate_negate] at this
  exact this

theorem multiply_nonpositive_of_nonnegative_of_nonpositive {a b : ℤ} (ha : 0 ≤ a) (hb : b ≤ 0) : a * b ≤ 0 := by
  rw [← multiply_zero a]
  exact multiply_nonnegative_left_monotone ha hb

theorem multiply_nonpositive_of_nonpositive_of_nonnegative {a b : ℤ} (ha : a ≤ 0) (hb : 0 ≤ b) : a * b ≤ 0 := by
  rw [← zero_multiply b]
  exact multiply_nonnegative_right_monotone hb ha
  
-- Tricky: We only require that c is nonnegative, a is totally cool to be negative because that will make a*b negative which preserves order
theorem multiply_less_equal_multiply {a b c d : ℤ} (hac : a ≤ c) (hbd : b ≤ d) (hb : 0 ≤ b) (hc : 0 ≤ c) : a * b ≤ c * d :=
  less_equal_transitive
  (multiply_nonnegative_right_monotone hb hac)
  (multiply_nonnegative_left_monotone hc hbd)
  
theorem multiply_nonpositive_left_antitone {a : ℤ} (ha : a ≤ 0) : Antitone (a * .) := by
  intro b c h
  have := multiply_nonnegative_left_monotone (negate_antitone ha) h
  simp at this
  rw [← negate_multiply_equal_negate_multiply, ← negate_multiply_equal_negate_multiply] at this
  exact less_equal_of_negate_less_equal_negate this

theorem multiply_nonpositive_right_antitone {c : ℤ} (hc : c ≤ 0) : Antitone (. * c) := by
  intro a b h
  simp
  rw [multiply_commutative a c, multiply_commutative b c]
  exact multiply_nonpositive_left_antitone hc h
  
theorem equal_add_positive_of_less_than {a b : ℤ} (h : a < b) :
    ∃ (n : ℕ), n ≠ 0 ∧ a + ↑n = b := by
  let ⟨n, hab⟩ := less_equal_of_less_than h
  have n_nonzero : n ≠ 0 := by
  { intro  hn
    rw [hn, ofNatural_zero, add_zero] at hab
    exact absurd hab (not_equal_of_less_than h) }
  apply Exists.intro n (And.intro n_nonzero hab)

theorem less_than_of_equal_add_positive {a b : ℤ} {n : ℕ} : n ≠ 0 → a + ↑n = b → a < b := by
  intro n_nonzero hab
  apply less_than_of_less_equal_of_not_equal
  . exact Exists.intro n hab
  . intro hab'
    have := congrArg (-b + .) (hab' ▸ hab)
    simp [negate_add_cancel_left, add_inverse_left] at this
    exact absurd (ofNatural_injective this) n_nonzero
    
theorem equal_ofNatural_positive_of_positive {a : ℤ} (h : 0 < a) : 
    ∃ n : ℕ, n ≠ 0 ∧ ↑n = a := 
  equal_add_positive_of_less_than h

theorem add_left_strict_monotone (a : ℤ) : StrictMonotone (a + .) := by
  intro b c h
  let ⟨hbc, hcb⟩ := less_than_equivalent_less_equal_not_less_equal.mp h
  apply less_than_equivalent_less_equal_not_less_equal.mpr
  apply And.intro
  . exact add_left_monotone a hbc
  . intro h'
    have : c ≤ b := (less_equal_of_add_less_equal_left h')
    exact absurd this hcb
  
theorem add_right_strict_monotone (c : ℤ) : StrictMonotone (. + c) := by
  intro a b h
  simp
  rw [add_commutative a c, add_commutative b c]
  exact add_left_strict_monotone c h

theorem less_than_of_add_less_than_left {a b c : ℤ} (h : a + b < a + c) : b < c := by
  have := add_left_strict_monotone (-a) h
  simp [negate_add_cancel_left] at this
  exact this

theorem less_than_of_add_less_than_right {a b c : ℤ} (h : a + c < b + c) : a < b := by
  rw [add_commutative a c, add_commutative b c] at h
  exact less_than_of_add_less_than_left h
  
theorem add_less_than_add {a b c d : ℤ} (hac : a < c) (hbd : b < d) : a + b < c + d :=
  less_than_transitive (add_right_strict_monotone b hac) (add_left_strict_monotone c hbd)

theorem less_than_add_of_nonnegative_left {a b : ℤ} (h : 0 < b) : a < b + a := by
  have := add_right_strict_monotone a h
  simp [zero_add] at this
  exact this

theorem less_than_add_of_nonnegative_right {a b : ℤ} (h : 0 < b) : a < a + b := by
  rw [add_commutative a b]
  exact less_than_add_of_nonnegative_left h

theorem less_than_of_subtract_positive {a b : ℤ} : 0 < b - a → a < b := by
  intro h
  have := add_right_strict_monotone a h
  simp [zero_add, ← subtract_definition, negate_add_cancel_right] at this
  exact this

theorem subtract_positive_of_less_than {a b : ℤ} : a < b → 0 < b - a := by
  intro h
  have := add_right_strict_monotone (-a) h
  simp [add_inverse] at this
  exact this
    
theorem less_than_of_subtract_negative {a b : ℤ} (h : a - b < 0) : a < b := by
  have := add_right_strict_monotone b h
  simp at this
  rw [zero_add, ← subtract_definition, negate_add_cancel_right] at this
  exact this

theorem subtract_negative_of_less_than {a b : ℤ} (h : a < b) : a - b < 0 := by
  have := add_right_strict_monotone (-b) h
  simp [add_inverse] at this
  exact this

theorem negate_strict_antitone : StrictAntitone negate := by
  intro a b h
  have ha := add_left_strict_monotone (-b) h
  simp [add_inverse_left] at ha
  have hb := add_right_strict_monotone (-a) ha
  simp [zero_add, add_associative, add_inverse, add_zero] at hb
  exact hb

theorem less_than_of_negate_less_than_negate {a b : ℤ} (h : -b < -a) : a < b :=
  suffices - -a < - - b by simp at this; exact this
  negate_strict_antitone h

theorem multiply_positive_left_strict_monotone {a : ℤ} (ha : 0 < a) : StrictMonotone (a * .) := by
  intro b c h
  let ⟨n, hn, hbc⟩ := equal_add_positive_of_less_than h
  let ⟨m, hm, ha⟩ := equal_ofNatural_positive_of_positive ha
  apply less_than_of_equal_add_positive
  . exact Natural.multiply_positive_of_positive hn hm
  . rw [ofNatural_multiply, ha, multiply_commutative _ a, ← left_distributive]
    exact congrArg (a * .) hbc
  
theorem multiply_positive_right_strict_monotone {c : ℤ} (hc : 0 < c) : StrictMonotone (. * c) := by
  intro a b h
  simp [multiply_commutative a c, multiply_commutative b c]
  exact multiply_positive_left_strict_monotone hc h

theorem multiply_positive {a b : ℤ} (ha : 0 < a) (hb : 0 < b) : 0 < a * b := by
  let ⟨n, hn, ha⟩ := equal_ofNatural_positive_of_positive ha
  let ⟨m, hm, hb⟩ := equal_ofNatural_positive_of_positive hb
  -- TODO: Need to make a nonzero theorem, also rename integer one to nonzero
  apply less_than_of_equal_add_positive 
  . exact (Natural.multiply_positive_of_positive hn hm)
  . rw [zero_add, ofNatural_multiply, ha, hb]

theorem multiply_negative {a b : ℤ} (ha : a < 0) (hb : b < 0) : 0 < a * b := by
  let ⟨n, hn, ha⟩ := equal_ofNatural_positive_of_positive (negate_strict_antitone ha)
  let ⟨m, hm, hb⟩ := equal_ofNatural_positive_of_positive (negate_strict_antitone hb)
  apply less_than_of_equal_add_positive
  . exact (Natural.multiply_positive_of_positive hn hm)
  . rw [zero_add, ofNatural_multiply, ha, hb, negate_definition, negate_definition, 
       ← negate_multiply_equal_negate_multiply, ← negate_multiply_equal_multiply_negate, negate_negate]

theorem multiply_negative_of_positive_of_negative {a b : ℤ} (ha : 0 < a) (hb : b < 0) : a * b < 0 := by
  rw [← multiply_zero a]
  exact multiply_positive_left_strict_monotone ha hb

theorem multiply_negative_of_negative_of_positive {a b : ℤ} (ha : a < 0) (hb : 0 < b) : a * b < 0 := by
  rw [← zero_multiply b]
  exact multiply_positive_right_strict_monotone hb ha

theorem multiply_less_than_multiply {a b c d : ℤ} (hac : a < c) (hbd : b < d) (hb : 0 < b) (hc : 0 < c) : a * b < c * d :=
  less_than_transitive
  (multiply_positive_right_strict_monotone hb hac)
  (multiply_positive_left_strict_monotone hc hbd)
  
theorem multiply_negative_left_strict_antitone {a : ℤ} (ha : a < 0) : StrictAntitone (a * .) := by
  intro b c h
  have := multiply_positive_left_strict_monotone (negate_strict_antitone ha) h
  simp [← negate_multiply_equal_negate_multiply, ← negate_multiply_equal_negate_multiply] at this
  exact less_than_of_negate_less_than_negate this
  
theorem multiply_negative_right_strict_antitone {c : ℤ} (hc : c < 0) : StrictAntitone (. * c) := by
  intro a b h
  simp [multiply_commutative a c, multiply_commutative b c]
  exact multiply_negative_left_strict_antitone hc h
  
-- TODO: The names are wrong, prove positive_left_* version, so switch
theorem positive_right_of_multiply_positive_of_positive_left {a b : ℤ} (h : 0 < a * b) (ha : 0 < a) : 0 < b := by
  match less_than_trichotomous 0 b with
  | Or.inl h_less => exact h_less
  | Or.inr (Or.inl h_equal) =>
    rw [← h_equal, multiply_zero] at h
    exact absurd h (less_than_irreflexive 0)
  | Or.inr (Or.inr h_greater) =>
    have := multiply_negative_of_positive_of_negative ha h_greater
    exact absurd (less_than_transitive this h) (less_than_irreflexive (a * b))
    
theorem positive_left_of_multiply_positive_of_positive_right {a b : ℤ} (h : 0 < a * b) (hb : 0 < b) : 0 < a := by
  rw [multiply_commutative] at h
  exact positive_right_of_multiply_positive_of_positive_left h hb
  
theorem negative_left_of_multiply_negative_of_positive_right {a b : ℤ} (h : a * b < 0) (hb : 0 < b) : a < 0 := by
  match less_than_trichotomous 0 a with
  | Or.inl a_positive =>
    have := multiply_positive a_positive hb
    exact absurd (less_than_transitive this h) (less_than_irreflexive 0)
  | Or.inr (Or.inl a_zero) =>
    rw [← a_zero, Integer.zero_multiply] at h
    exact absurd h (less_than_irreflexive 0)
  | Or.inr (Or.inr a_negative) => exact a_negative
  
theorem negative_right_of_multiply_negative_of_positive_left {a b : ℤ} (h : a * b < 0) (ha : 0 < a) : b < 0 := by
  rw [multiply_commutative] at h
  exact negative_left_of_multiply_negative_of_positive_right h ha

theorem less_than_multiply_cancel_left_of_positive {a b c : ℤ} (h : a * b < a * c) (ha : 0 < a) : b < c := by
  -- If we subtract a*b from both sides and distribute (undistribute?), we have a * (c - b). We proved earlier (specifically because I realized that I needed it to prove this one), that if we have a * b > 0 and a > 0, then b > 0. Applying this gives c - b > 0, and then we apply the theorem which gives b < c.
  -- This was a good example of having no clue what to do, I tried to appeal to the existence of the natural number and even do induction on it, but I needed to develop the simpler theorem about sharing signs first and then apply it here.
  have := add_right_strict_monotone (-(a*b)) h
  simp [multiply_zero, add_inverse, negate_multiply_equal_multiply_negate, ← left_distributive] at this
  exact less_than_of_subtract_positive (positive_right_of_multiply_positive_of_positive_left this ha)
  
theorem less_than_multiply_cancel_right_of_positive {a b c : ℤ} (h : a * c < b * c) (hc : 0 < c) : a < b := by
  rw [multiply_commutative a c, multiply_commutative b c] at h
  exact less_than_multiply_cancel_left_of_positive h hc
  
theorem less_equal_multiply_cancel_left_of_positive {a b c : ℤ} (h : a * b ≤ a * c) (ha : 0 < a) : b ≤ c :=
  match less_than_or_equal_of_less_equal h with
  | Or.inl h_less => less_equal_of_less_than <|
    less_than_multiply_cancel_left_of_positive h_less ha
  | Or.inr h_equal => less_equal_of_equal <|
    multiply_left_cancel h_equal (not_equal_of_less_than ha).symm

theorem less_equal_multiply_cancel_right_of_positive {a b c : ℤ} (h : a * c ≤ b * c) (hc : 0 < c) : a ≤ b := by
  rw [multiply_commutative a c, multiply_commutative b c] at h
  exact less_equal_multiply_cancel_left_of_positive h hc
#+end_src

** Rational
:PROPERTIES:
:header-args: :tangle Barb/Data/Rational.lean
:END:

#+begin_src lean4
import Barb.Algebra
import Barb.Data.Integer
import Barb.Data.Option
import Barb.Logic

open Integer (NonZeroInteger)
#+end_src

*** Definition

Same business as the integer quotient definition. A rational number is
the equivalence class over pairs of integers and non zero integers
with respect to the relation $(a, b) \sim (c, d) \equiv ad = cb$.

#+begin_src lean4
def RationalEquivalent : (ℤ × NonZeroInteger) → (ℤ × NonZeroInteger) → Prop
  | (a, ⟨b, _⟩), (c, ⟨d, _⟩) => a * d = c * b

theorem RationalEquivalent.reflexive : Relation.Reflexive RationalEquivalent :=
  λ _ => rfl

theorem RationalEquivalent.symmetric : Relation.Symmetric RationalEquivalent := by
  intro (a, ⟨b, _⟩) (c, ⟨d, _⟩) (h_ab_cd : a * d = c * b)
  exact h_ab_cd.symm

theorem RationalEquivalent.transitive : Relation.Transitive RationalEquivalent := by
  intro (a, ⟨b, b_nonzero⟩) (c, ⟨d, d_nonzero⟩) (e, ⟨f, _⟩)
  intro (h_ab_cd : a * d = c * b) (h_cd_ef : c * f = e * d)
  show a * f = e * b
  cases Integer.decideEqual c 0 with
  | isTrue c_zero =>
    have ad_zero := c_zero ▸ h_ab_cd
    rw [Integer.zero_multiply] at ad_zero
    have a_zero := Or.resolve_right (Integer.equal_zero_of_multiply_equal_zero ad_zero) d_nonzero
    have ed_zero := c_zero ▸ h_cd_ef
    rw [Integer.zero_multiply] at ed_zero
    have e_zero := Or.resolve_right (Integer.equal_zero_of_multiply_equal_zero ed_zero.symm) d_nonzero
    simp [a_zero, e_zero, Integer.multiply_zero, Integer.zero_multiply]
  | isFalse c_nonzero =>
    have h_equal := calc
      (c * d) * (a * f) = (c * f) * (a * d) := by simp [Integer.multiply_associative, Integer.multiply_commutative, Integer.multiply_left_commutative]
      _ = (e * d) * (a * d) := congrArg (. * _) h_cd_ef
      _ = (e * d) * (c * b) := congrArg (_ * .) h_ab_cd
      _ = (c * d) * (e * b) := by simp [Integer.multiply_associative, Integer.multiply_commutative, Integer.multiply_left_commutative]
    have cd_nonzero := Integer.multiply_nonzero_of_nonzero c_nonzero d_nonzero
    exact Integer.multiply_left_cancel h_equal cd_nonzero

theorem RationalEquivalent.is_equivalence : Equivalence RationalEquivalent :=
  { refl := RationalEquivalent.reflexive, symm := RationalEquivalent.symmetric, trans := RationalEquivalent.transitive }

instance instanceHasEquivRationalEquivalent : HasEquiv (Integer × NonZeroInteger) where
  Equiv := RationalEquivalent

instance instanceSetoidRationalEquivalent : Setoid (Integer × NonZeroInteger) where
  r := RationalEquivalent
  iseqv := RationalEquivalent.is_equivalence

@[simp] def RationalEquivalent.definition : (x ≈ y) = RationalEquivalent x y := rfl

instance decideRationalEquivalent (x y : ℤ × NonZeroInteger) : Decidable (x ≈ y) :=
  let (a, ⟨b, _⟩) := x
  let (c, ⟨d, _⟩) := y
  Integer.decideEqual (a * d) (c * b)

instance decideRationalEquivalentQuotientEqual : DecidableEq (Quotient instanceSetoidRationalEquivalent) :=
  inferInstance

def Rational := Quotient instanceSetoidRationalEquivalent

namespace Rational

notation "ℚ" => Rational

instance decideEqual : DecidableEq Rational := decideRationalEquivalentQuotientEqual

instance : OfNat Rational n where
  ofNat := ⟦(Integer.ofNatural (Natural.fromNat n), ⟨1, by decide⟩)⟧

instance zero : Rational := ⟦(0, ⟨1, by decide⟩)⟧

theorem zero_definition : (0 : ℚ) = Quotient.mk instanceSetoidRationalEquivalent (0, ⟨1, by decide⟩) := rfl

instance one : Rational := ⟦(1, ⟨1, by decide⟩)⟧

theorem one_definition : (1 : ℚ) = Quotient.mk instanceSetoidRationalEquivalent (1, ⟨1, by decide⟩) := rfl
#+end_src

*** Operations

#+begin_src lean4
def add : ℚ → ℚ → ℚ :=
  let add' := λ
  ((a, ⟨b, b_nonzero⟩) : ℤ × NonZeroInteger)
  ((c, ⟨d, d_nonzero⟩) : ℤ × NonZeroInteger) =>
  let bd_nonzero := Integer.multiply_nonzero_of_nonzero b_nonzero d_nonzero
  (a*d + c*b, ⟨b*d, bd_nonzero⟩)
  Quotient.map₂ add' <| by
  intro (a, ⟨b, b_nonzero⟩) (a', ⟨b', b'_nonzero⟩) (h₁ : a * b' = a' * b)
  intro (c, ⟨d, d_nonzero⟩) (c', ⟨d', d'_nonzero⟩) (h₂ : c * d' = c' * d)
  show (a*d + c*b) * (b'*d') = (a'*d' + c'*b') * (b*d)
  rw [Integer.right_distributive, ← Integer.multiply_associative (a * d) b' d', Integer.multiply_associative a d b', Integer.multiply_commutative d b', ← Integer.multiply_associative a b' d, h₁, Integer.multiply_commutative b' d', ← Integer.multiply_associative (c * b) d' b', Integer.multiply_associative c b d', Integer.multiply_commutative b d', ← Integer.multiply_associative c d' b, h₂, Integer.multiply_associative (a' * b) d d', Integer.multiply_commutative d d', Integer.multiply_associative a' b (d' * d), ← Integer.multiply_associative b d' d, Integer.multiply_commutative b d', Integer.multiply_associative d' b d, ← Integer.multiply_associative a' d' (b * d), Integer.multiply_associative (c' * d) b b', Integer.multiply_commutative b b', ← Integer.multiply_associative (c' * d) b' b, Integer.multiply_associative c' d b', Integer.multiply_commutative d b', ← Integer.multiply_associative c' b' d, Integer.multiply_associative (c' * b') d b, Integer.multiply_commutative d b, ← Integer.right_distributive]

instance : Add Rational where add := add

@[simp] theorem add_definition : add x y = x + y := rfl

def multiply : ℚ → ℚ → ℚ :=
  let multiply' := λ
  ((a, ⟨b, b_nonzero⟩) : ℤ × NonZeroInteger)
  ((c, ⟨d, d_nonzero⟩) : ℤ × NonZeroInteger) =>
  let bd_nonzero := Integer.multiply_nonzero_of_nonzero b_nonzero d_nonzero
  (a*c, ⟨b*d, bd_nonzero⟩)
  Quotient.map₂ multiply' <| by
  intro (a, ⟨b, b_nonzero⟩) (a', ⟨b', b'_nonzero⟩) (hab : a * b' = a' * b)
  intro (c, ⟨d, d_nonzero⟩) (c', ⟨d', d'_nonzero⟩) (hcd : c * d' = c' * d)
  show (a*c) * (b'*d') = (a'*c') * (b*d)
  calc
    (a*c) * (b'*d')
      = (a*b') * (c*d') := by simp [Integer.multiply_associative, Integer.multiply_commutative, Integer.multiply_left_commutative]
    _ = (a'*b) * (c*d') := congrArg (. * _) hab
    _ = (a'*b) * (c'*d) := congrArg (_ * .) hcd
    _ = (a'*c') * (b*d) := by simp [Integer.multiply_associative, Integer.multiply_commutative, Integer.multiply_left_commutative]

instance : Mul Rational where mul := multiply

@[simp] theorem multiply_definition : multiply x y = x * y := rfl

def negate : ℚ → ℚ :=
  let negate' := λ ((a, ⟨b, b_nonzero⟩) : ℤ × NonZeroInteger) => (-a, ⟨b, b_nonzero⟩)
  Quotient.map negate' <| by
  intro (a, ⟨b, b_nonzero⟩) (a', ⟨b', b'_nonzero⟩) (h : a*b' = a'*b)
  show (-a)*b' = (-a')*b
  rw [← Integer.negate_multiply_equal_negate_multiply, h, Integer.negate_multiply_equal_negate_multiply]

instance : Neg Rational where neg := negate

@[simp] theorem negate_definition : negate x = -x := rfl
#+end_src

TODO: Comment about reciprocal.

#+begin_src lean4
def preReciprocal : ℤ × NonZeroInteger → Option ℚ
  | (a, ⟨b, _⟩) => if ha : a ≠ 0 then some ⟦(b, ⟨a, ha⟩)⟧ else none

@[simp]
theorem preReciprocal_none (x : ℤ × NonZeroInteger) (h : x.1 = 0) : preReciprocal x = none := by
  simp [preReciprocal, h]

@[simp]
theorem preReciprocal_some (x : ℤ × NonZeroInteger) (h : x.1 ≠ 0) :
    preReciprocal x = some ⟦(x.2.1, ⟨x.1, h⟩)⟧ := by
  simp [preReciprocal, h]

theorem numerator_nonzero_of_nonzero : ∀ {x : ℤ × NonZeroInteger}, ⟦x⟧ ≠ (0 : ℚ) → x.1 ≠ 0 := by
  intro (a, ⟨b, b_nonzero⟩) h
  have h' : Quotient.mk instanceSetoidRationalEquivalent (a, ⟨b, b_nonzero⟩) ≠ (0 : ℚ) := h
  intro ha
  simp at ha
  apply (absurd . h')
  apply Quotient.sound
  show a * 1 = 0 * b
  simp [ha, Integer.zero_multiply, Integer.multiply_zero]

def reciprocal' : ℚ → Option ℚ :=
  Quotient.lift preReciprocal <| by
  intro ⟨a, b, hb⟩ ⟨c, d, hd⟩ (h : a * d = c * b)
  cases Decidable.em (a = 0)
  <;> cases Decidable.em (b = 0)
  <;> simp_all [preReciprocal, preReciprocal_none, preReciprocal_some]
  case inl.inr _ =>
    rw [Integer.zero_multiply] at h
    have := Or.resolve_right (Integer.equal_zero_of_multiply_equal_zero h.symm) hb
    simp [this]
  case inr.inr ha =>
    suffices c ≠ 0 by
    { simp [this]
      apply Quotient.sound
      show b * c = d * a
      simp [h, Integer.multiply_commutative] }
    apply And.left
    apply Integer.nonzero_of_multiply_nonzero
    intro hcb
    have := Integer.multiply_nonzero_of_nonzero ha hd
    exact absurd (hcb.symm.trans h.symm) this.symm

def reciprocal (x : ℚ) (h : x ≠ 0) : ℚ :=
  Option.get (reciprocal' x) <| by
  have ⟨(a, ⟨b, b_nonzero⟩), hab⟩ := Quotient.exists_rep x
  have a_nonzero := numerator_nonzero_of_nonzero (hab.symm ▸ h)
  rw [← hab, reciprocal', Quotient.lift_construct, Option.isSome]
  have := preReciprocal_some ⟨a, b, b_nonzero⟩ a_nonzero
  simp [this]
#+end_src

#+begin_src lean4
theorem add_associative : ∀ (x y z : ℚ), (x + y) + z = x + (y + z) := by
  apply Quotient.ind₃
  intro (a, ⟨b, _⟩) (c, ⟨d, _⟩) (e, ⟨f, _⟩)
  apply Quotient.sound
  show ((a*d + c*b)*f + e*(b*d))*(b*(d*f)) = (a*(d*f) + (c*f + e*d)*b)*((b*d)*f)
  let n_left := ((a*d + c*b)*f + e*(b*d)); let n_right := (a*(d*f) + (c*f + e*d)*b)
  let d_left := (b*(d*f)); let d_right := ((b*d)*f)
  suffices n_left = n_right ∧ d_left = d_right by simp [this.left, this.right]
  apply And.intro
  . simp [n_left, n_right]
    rw [Integer.right_distributive, Integer.multiply_associative a d f,
    Integer.add_associative, Integer.multiply_right_commutative, ← Integer.multiply_associative e b d,
    Integer.multiply_right_commutative e b d, ← Integer.right_distributive]
  . exact (Integer.multiply_associative _ _ _).symm

theorem add_commutative : ∀ (x y : ℚ), x + y = y + x := by
  apply Quotient.ind₂
  intro (a, ⟨b, _⟩) (c, ⟨d, _⟩)
  apply Quotient.sound
  show (a*d + c*b)*(d*b) = (c*b + a*d)*(b*d)
  suffices (a*d + c*b) = (c*b + a*d) ∧ d*b = b*d by rw [this.left, this.right]
  apply And.intro (Integer.add_commutative _ _) (Integer.multiply_commutative _ _)

theorem add_zero : ∀ (x : ℚ), x + 0 = x := by
  apply Quotient.ind
  intro (a, ⟨b, _⟩)
  apply Quotient.sound
  show (a*1 + 0*b)*b = a*(b*1)
  simp [Integer.multiply_one, Integer.zero_multiply, Integer.add_zero]

theorem add_inverse : ∀ (x : ℚ), x + (-x) = 0 := by
  apply Quotient.ind
  intro (a, ⟨b, _⟩)
  apply Quotient.sound
  show (a*b + (-a)*b) * 1 = 0 * (b*b)
  rw [Integer.multiply_one, ← Integer.right_distributive, Integer.add_inverse,
    Integer.zero_multiply, Integer.zero_multiply]

theorem multiply_associative : ∀ (x y z : ℚ), (x * y) * z = x * (y * z) := by
  apply Quotient.ind₃
  intro (a, ⟨b, _⟩) (c, ⟨d, _⟩) (e, ⟨f, _⟩)
  apply Quotient.sound
  show ((a*c)*e) * (b*(d*f)) = (a*(c*e)) * ((b*d)*f)
  simp [Integer.multiply_associative]

theorem multiply_commutative : ∀ (x y : ℚ), x * y = y * x := by
  apply Quotient.ind₂
  intro (a, ⟨b, _⟩) (c, ⟨d, _⟩)
  apply Quotient.sound
  show (a*c) * (d*b) = (c*a) * (b*d)
  simp [Integer.multiply_commutative]

theorem multiply_one : ∀ (x : ℚ), x * 1 = x := by
  apply Quotient.ind
  intro (a, ⟨b, _⟩)
  apply Quotient.sound
  show (a*1) * b = a * (b*1)
  simp [Integer.multiply_one]

theorem left_distributive : ∀ (x y z : ℚ), x * (y + z) = x * y + x * z := by
  apply Quotient.ind₃
  intro (a, ⟨b, _⟩) (c, ⟨d, _⟩) (e, ⟨f, _⟩)
  apply Quotient.sound
  show (a*(c*f + e*d)) * ((b*d)*(b*f)) = ((a*c)*(b*f) + (a*e)*(b*d))*(b*(d*f))
  simp [Integer.multiply_associative, Integer.multiply_commutative, Integer.left_distributive, Integer.multiply_left_commutative]

theorem right_distributive : ∀ (x y z : ℚ), (x + y) * z = x * z + y * z := by
  intro x y z
  rw [multiply_commutative, left_distributive, multiply_commutative z x, multiply_commutative z y]

theorem multiply_inverse : ∀ (x : ℚ) (h : x ≠ 0), x * (reciprocal x h) = 1 := by
  apply Quotient.ind
  intro (a, ⟨b, b_nonzero⟩) h
  have h' := numerator_nonzero_of_nonzero h
  simp at h'
  simp [reciprocal, reciprocal']
  have h_some := (preReciprocal_some (a, ⟨b, b_nonzero⟩) h')
  simp [h_some]
  apply Quotient.sound
  show (a*b)*1 = 1*(b*a)
  simp [Integer.multiply_commutative]

instance field : Field Rational where
  add_associative := add_associative
  add_commutative := add_commutative
  add_zero := add_zero
  add_inverse := add_inverse

  multiply_associative := multiply_associative
  multiply_commutative := multiply_commutative
  multiply_one := multiply_one

  left_distributive := left_distributive
  right_distributive := right_distributive

  reciprocal := reciprocal
  multiply_inverse := multiply_inverse

def subtract (x y : ℚ) : ℚ := x + (-y)

instance : Sub Rational where sub := subtract

@[simp]
theorem subtract_definition (x y : ℚ) : x + (-y) = x - y := rfl

def divide (x y : ℚ) (y_nonzero : y ≠ 0) : ℚ := x * (reciprocal y y_nonzero)

theorem negate_involutive : Function.Involutive negate := by
  apply Quotient.ind
  intro (a, ⟨b, b_nonzero⟩)
  apply Quotient.sound
  show (- - a)*b = a * b
  rw [Integer.negate_negate]

@[simp]
theorem negate_negate : ∀ x : ℚ, - -x = x := λ x => negate_involutive x

#+end_src

*** Operation lemmas

#+begin_src lean4
-- TODO: Copy pasted from Integers, this is all general to rings I think
-- Lesson (worth writing about): If you start building up a collection theorems which only appeal to a few lemmas you proved earlier, it's time to abstract because you are dealing with a more general structure of which your original type is an example

theorem zero_add (a : ℚ) : 0 + a = a := by
  rw [add_commutative, add_zero]

theorem multiply_zero : ∀ (a : ℚ), a * 0 = 0 := by
  apply Quotient.ind
  intro (n, m)
  apply Quotient.sound
  show (n * 0) * 1 = 0 * (m * 1)
  simp [Integer.multiply_zero, Integer.zero_multiply]

theorem zero_multiply (a : ℚ) : 0 * a = 0 := by
  rw [multiply_commutative, multiply_zero]

theorem one_multiply (a : ℚ) : 1 * a = a := by
  rw [multiply_commutative, multiply_one]

theorem add_left_commutative (n m k : ℚ) : n + (m + k) = m + (n + k) := by
  rw [← add_associative, add_commutative n m, add_associative]

theorem add_right_commutative (n m k : ℚ) : (n + m) + k = (n + k) + m := by
  rw [add_associative, add_commutative m k, ← add_associative]

theorem add_inverse_left (a : ℚ) : -a + a = 0 := by
  rw [add_commutative, add_inverse]

theorem add_left_cancel {a b c : ℚ} (h : a + b = a + c) : b = c := by
  have : -a + (a + b) = -a + (a + c) := by rw [h]
  simp [← add_associative, add_inverse_left, zero_add] at this
  exact this

theorem add_right_cancel {a b c : ℚ} (h : a + c = b + c) : a = b := by
  rewrite [add_commutative a c, add_commutative b c] at h
  exact add_left_cancel h

theorem negate_add_cancel_left (a b : ℚ) : -a + (a + b) = b := by
  rw [← add_associative (-a) a b, add_inverse_left, zero_add]

theorem negate_add_cancel_right (a b : ℚ) : (a + -b) + b = a := by
  rw [add_associative, add_inverse_left, add_zero]

theorem add_negate_cancel_left (a b : ℚ) : a + (-a + b) = b := by
  rw [← add_associative, add_inverse, zero_add]

theorem add_negate_cancel_right (a b : ℚ) : (a + b) + -b = a := by
  rw [add_associative, add_inverse, add_zero]

theorem negate_zero : (0 : ℚ) = (-0 : ℚ) := rfl

theorem subtract_self (a : ℚ) : a - a = 0 := add_inverse a

theorem subtract_zero (a : ℚ) : a - 0 = a := by
  rw [← subtract_definition, ← negate_zero, add_zero]

theorem zero_subtract (a : ℚ) : 0 - a = -a := by
  rw [← subtract_definition, zero_add]

theorem negate_equal_of_add_equal_zero {a b : ℚ} (h : a + b = 0) : a = -b := by
  rw [← add_zero a, ← add_inverse (b), ← add_associative, h, zero_add]

theorem subtract_equal_zero_of_equal {a b : ℚ} (h : a = b) : a - b = 0 := by
  rw [← h, subtract_self]

theorem equal_of_subtract_equal_zero {a b : ℚ} (h : a - b = 0) : a = b := by
  rw [← add_zero a, ← add_inverse b, add_commutative b, ← add_associative, subtract_definition, h, zero_add]

theorem negate_add (a b : ℚ) : -(a + b) = -a + -b := by
  apply add_left_cancel (a := a + b)
  rw [add_inverse, add_associative, ← add_associative b (-a) (-b), add_commutative b (-a),
     ← add_associative a, ← add_associative, add_inverse, zero_add, add_inverse]

theorem subtract_subtract (a b c : ℚ) : (a - b) - c = a - (b + c) := by
  apply Eq.symm
  rw [← subtract_definition, negate_add, ← add_associative, subtract_definition, subtract_definition]

theorem negate_subtract {a b : ℚ} : -(a - b) = b - a := by
  calc
    -(a - b) = -(a + -b) := rfl
    _ = -a + (- -b) := negate_add a (-b)
    _ = -a + b := congrArg (_ + .) (negate_negate _)
    _ = b + -a := add_commutative _ _
    _ = b - a := subtract_definition _ _

theorem subtract_subtract_self (a b : ℚ) : a - (a - b) = b := by
  rw [← subtract_definition, negate_subtract, ← subtract_definition,
    add_commutative (b) (-a), add_negate_cancel_left]

-- Looked at proof in lean std which uses negate_equal_of_add_equal_zero. This was foreign to me.
-- Observation is that conclusion is of the form we would like here, we need a' = a * b and b' = -a * b, and then the theorem will tell us -(a * b) = -a * b, which is our desired result. So we need to provide (-(a * b)) + (-a * b) = 0, which we can do.
theorem negate_multiply_equal_negate_multiply (a b : ℚ) : -(a * b) = -a * b := by
  apply Eq.symm
  apply negate_equal_of_add_equal_zero
  rw [← right_distributive, add_commutative, add_inverse, zero_multiply]

theorem negate_multiply_equal_multiply_negate (a b : ℚ) : -(a * b) = a * -b := by
  rw [multiply_commutative, negate_multiply_equal_negate_multiply, multiply_commutative]
#+end_src

*** Order

#+begin_src lean4
def LessThan (x y : ℚ) : Prop :=
  let positive'
    | (a, ⟨b, b_nonzero⟩) => ∃ v : Integer.PositiveInteger × Integer.PositiveInteger,
      let (⟨c, _⟩, ⟨d, d_positive⟩) := v;
      RationalEquivalent (a, ⟨b, b_nonzero⟩) (c, ⟨d, (not_equal_of_less_than d_positive).symm⟩)
  Quotient.liftOn (y - x) positive' <| by
  intro a b (h : a ≈ b)
  apply propext
  apply Iff.intro
  . simp
    intro ⟨v, hv⟩
    apply Exists.intro v (h.symmetric.transitive hv)
  . simp
    intro ⟨v, hv⟩
    apply Exists.intro v (h.transitive hv)

instance : LT Rational where
  lt := LessThan

@[simp] theorem less_than_definition : (x < y) = (LessThan x y) := rfl

def LessEqual (x y : ℚ) : Prop := x < y ∨ x = y

instance : LE Rational where
  le := LessEqual

@[simp] theorem less_equal_definition : (x ≤ y) = (LessEqual x y) := rfl

theorem LessThan.irreflexive : Relation.Irreflexive LessThan := by
  intro x
  unfold LessThan
  simp
  rw [subtract_self, zero_definition, Quotient.lift_construct_on]
  intro ⟨(⟨a, a_positive⟩, ⟨b, _⟩), (hv : 0 * b = a * 1)⟩
  rw [Integer.zero_multiply, Integer.multiply_one] at hv
  exact absurd hv (not_equal_of_less_than a_positive)
  
-- Readable proof of this and asymmetric property are in the last few pages of black notebook, we should turn them into latex. Gist for this one is just to plug in one equation into the other
-- This proof is easy once you write out the equations in terms of fractions like c//d - a//b = p//q and solve.
-- TODO: Is it possible to avoid the case split on c = 0? I think it's gotta be, the equations are the same at the end
theorem LessThan.transitive : Relation.Transitive LessThan := by
  apply Quotient.ind₃
  intro ⟨a, b, b_nonzero⟩ ⟨c, d, d_nonzero⟩ ⟨e, f, f_nonzero⟩
  intro ⟨(⟨p, p_positive⟩, ⟨q, q_positive⟩), (hpq : (c*b + -a*d)*q = p*(d*b))⟩
  intro ⟨(⟨s, s_positive⟩, ⟨t, t_positive⟩), (hst : (e*d + -c*f)*t = s*(f*d))⟩
  match (Decidable.em (c = 0)) with
  | Or.inl c_zero =>
    rw [c_zero, Integer.zero_multiply, Integer.zero_add, Integer.multiply_associative, Integer.multiply_left_commutative, ← Integer.negate_multiply_equal_negate_multiply, Integer.multiply_left_commutative p _ _] at hpq
    have hpq' := Integer.multiply_left_cancel hpq d_nonzero
    rw [c_zero, ← Integer.negate_zero, Integer.zero_multiply, Integer.add_zero, Integer.multiply_associative, Integer.multiply_left_commutative, ← Integer.multiply_associative s _ _, Integer.multiply_commutative _ d] at hst
    have hst' := Integer.multiply_left_cancel hst d_nonzero
    have : (e*t)*(b*q) + (-(a*q))*(f*t) = (s*f)*(b*q) + (p*b)*(f*t) := by simp [hpq', hst']
    have hetbq : e*t*(b*q) = (e*b) * (q*t) := by simp [Integer.multiply_commutative, Integer.multiply_left_commutative]
    have haqft : (a*q)*(f*t) = (a*f)*(q*t) := by simp [Integer.multiply_commutative, Integer.multiply_left_commutative]
    have hsfbq : (s*f)*(b*q) = (s*q)*(f*b) := by simp [Integer.multiply_commutative, Integer.multiply_left_commutative]
    have hpbft : (p*b)*(f*t) = (p*t)*(f*b) := by simp [Integer.multiply_commutative, Integer.multiply_left_commutative]
    rw [hetbq, ← Integer.negate_multiply_equal_negate_multiply, haqft, Integer.negate_multiply_equal_negate_multiply, Integer.negate_multiply_equal_negate_multiply, hsfbq, hpbft, ← Integer.right_distributive, ← Integer.right_distributive] at this
    let qt : Integer.PositiveInteger := ⟨q*t, Integer.multiply_positive q_positive t_positive⟩
    let sqpt : Integer.PositiveInteger := ⟨(s * q + p * t), Integer.add_less_than_add (Integer.multiply_positive s_positive q_positive) (Integer.multiply_positive p_positive t_positive)⟩
    exact Exists.intro (sqpt, qt) this
  | Or.inr c_nonzero =>
    have hpq' := congrArg (. + (a*d*q)) hpq
    simp at hpq'
    rw [Integer.right_distributive, ← Integer.negate_multiply_equal_negate_multiply, ← Integer.negate_multiply_equal_negate_multiply, Integer.add_associative, Integer.add_inverse_left, Integer.add_zero] at hpq'
    rw [Integer.right_distributive] at hst
    have hst' := congrArg (. * (c*b*q)) hst
    simp at hst'
    have foo : e*d*t*(c*b*q) = ((c*d)*(t*q))*(e*b) := by simp [Integer.multiply_commutative, Integer.multiply_left_commutative]
    have bar : c * f * t * (a * d * q) = ((c*d)*(t*q))*(a*f) := by simp [Integer.multiply_commutative, Integer.multiply_left_commutative]
    rw [Integer.right_distributive, congrArg ((-c * f * t) * .) hpq', Integer.left_distributive, foo, Integer.add_left_commutative, ← Integer.negate_multiply_equal_negate_multiply, ← Integer.negate_multiply_equal_negate_multiply, ← Integer.negate_multiply_equal_negate_multiply] at hst'
    have dark := congrArg ((c * f * t * (p * (d * b))) + .) hst'
    simp at dark
    have poo : c * f * t * (p * (d * b)) = (f*b)*((c*d)*(t*p)) := by simp [Integer.multiply_commutative, Integer.multiply_left_commutative]
    have bear : s * (f * d) * (c * b * q) = (f*b)*((c*d)*(s*q)) := by simp [Integer.multiply_commutative, Integer.multiply_left_commutative]
    rw [Integer.add_negate_cancel_left, ← Integer.negate_multiply_equal_negate_multiply, bar, Integer.negate_multiply_equal_multiply_negate, ← Integer.left_distributive, Integer.multiply_associative, poo, bear, ← Integer.left_distributive, ← Integer.left_distributive, Integer.multiply_left_commutative (f*b) _ _] at dark
    have cd_nonzero : c*d ≠ 0 := Integer.multiply_nonzero_of_nonzero c_nonzero d_nonzero
    have kick := Integer.multiply_left_cancel dark cd_nonzero
    rw [Integer.multiply_commutative (t*q) _, Integer.multiply_commutative (f*b) _, Integer.negate_multiply_equal_negate_multiply] at kick
    have htq := Integer.multiply_positive t_positive q_positive
    have htpsq := Integer.add_less_than_add (Integer.multiply_positive t_positive p_positive) (Integer.multiply_positive s_positive q_positive)
    rw [Integer.add_zero] at htpsq
    let u : Integer.PositiveInteger := ⟨t * p + s * q, htpsq⟩
    let v : Integer.PositiveInteger := ⟨t * q, htq⟩
    exact Exists.intro (u, v) kick

theorem LessThan.asymmetric : Relation.Asymmetric LessThan := by
  unfold Relation.Asymmetric
  intro x y hxy hyx
  exact LessThan.irreflexive x (LessThan.transitive hxy hyx)
  
theorem positive_or_negative_of_equal_positive : ∀ {a : ℤ} {b : NonZeroInteger} {c d : Integer.PositiveInteger}, 
    (a, b) ≈ (c.val, ⟨d, (not_equal_of_less_than d.property).symm⟩) →
    (0 < a ∧ 0 < b.val) ∨ (a < 0 ∧ b.val < 0) := by
  intro a ⟨b, b_nonzero⟩ ⟨c, c_positive⟩ ⟨d, d_positive⟩
  intro (h : a * d = c * b)
  simp
  match less_than_trichotomous 0 b with
  | Or.inl hb =>
    have ha := Integer.positive_left_of_multiply_positive_of_positive_right
      (h.symm ▸ Integer.multiply_positive c_positive hb) d_positive
    exact Or.inl (And.intro ha hb)
  | Or.inr (Or.inl hb) => exact absurd hb.symm b_nonzero
  | Or.inr (Or.inr hb) =>
    have ha := Integer.negative_left_of_multiply_negative_of_positive_right
      (h.symm ▸ Integer.multiply_negative_of_positive_of_negative c_positive hb) d_positive
    exact Or.inr (And.intro ha hb)
  skip

theorem equal_positive_of_positive_or_negative : ∀ {a : ℤ} {b : NonZeroInteger},
    (0 < a ∧ 0 < b.val) ∨ (a < 0 ∧ b.val < 0) →
    ∃ u : Integer.PositiveInteger × Integer.PositiveInteger,
      let (⟨c, _⟩, ⟨d, d_positive⟩) := u
      (a, b) ≈ (c, ⟨d, (not_equal_of_less_than d_positive).symm⟩)
  | a, ⟨b, _⟩, Or.inl ⟨ha, hb⟩ =>
    Exists.intro (⟨a, ha⟩, ⟨b, hb⟩) (RationalEquivalent.reflexive _)
  | a, ⟨b, _⟩, Or.inr ⟨ha, hb⟩ => by
    apply Exists.intro (⟨-a, Integer.negate_strict_antitone ha⟩, ⟨-b, Integer.negate_strict_antitone hb⟩)
    simp [RationalEquivalent]
    rw [← Integer.negate_multiply_equal_multiply_negate, ← Integer.negate_multiply_equal_negate_multiply]

theorem less_than_of_subtract_positive {x y : ℚ} : 0 < y - x → x < y :=
  Quotient.inductionOn₂ x y <| by
  intro ⟨a, b, b_nonzero⟩ ⟨c, d, d_nonzero⟩
  intro ⟨(⟨u, u_positive⟩, ⟨v, v_positive⟩), (h : ((c * b + -a * d) * 1 + -0 * (d * b)) * v = u * (d * b * 1))⟩
  rw [Integer.multiply_one, ← Integer.negate_zero, Integer.zero_multiply, Integer.add_zero, Integer.multiply_one] at h
  apply Exists.intro (⟨u, u_positive⟩, ⟨v, v_positive⟩) h

theorem subtract_nonnegative_of_less_than {x y : ℚ} : x < y → 0 < y - x :=
  Quotient.inductionOn₂ x y <| by
  intro ⟨a, b, b_nonzero⟩ ⟨c, d, d_nonzero⟩
  intro ⟨(⟨u, u_positive⟩, ⟨v, v_positive⟩), (h : (c * b + -a * d) * v = u * (d * b))⟩
  apply Exists.intro (⟨u, u_positive⟩, ⟨v, v_positive⟩)
  have : Natural.fromNat 0 = (0 : ℤ) := rfl
  simp [Integer.multiply_one]
  rw [this, ← Integer.negate_zero, Integer.zero_multiply, Integer.add_zero]
  exact h

instance decidePositive (x : ℚ) : Decidable (0 < x) :=
  Quotient.recOnSubsingleton x
  λ ((a, ⟨b, b_nonzero⟩) : ℤ × Integer.NonZeroInteger) =>
  if h : (0 < a ∧ 0 < b) ∨ (a < 0 ∧ b < 0) then
    -- TODO: Figure out how to not have this
    let h' := by
      have : Natural.fromNat 0 = (0 : ℤ) := rfl
      rw [this, ← Integer.negate_zero, Integer.zero_multiply, Integer.multiply_one, Integer.add_zero]
      simp [Integer.multiply_one]
      exact h
    isTrue (equal_positive_of_positive_or_negative h')
  else
    let positive_or_negative_of_equal_positive' :
        (0 : ℚ) < Quotient.mk instanceSetoidRationalEquivalent (a, ⟨b, b_nonzero⟩) → (0 < a ∧ 0 < b) ∨ (a < 0 ∧ b < 0) := by
      simp [LessThan, subtract_zero, Quotient.lift_construct_on]
      intro ⟨(c, d), h⟩
      exact positive_or_negative_of_equal_positive h
    isFalse (mt positive_or_negative_of_equal_positive' h)

instance decideLessThan (x y : ℚ) : Decidable (x < y) :=
  if h : 0 < y - x then
    isTrue (less_than_of_subtract_positive h)
  else
    isFalse (mt subtract_nonnegative_of_less_than h)

theorem LessThan.connected : Relation.Connected LessThan := by
  unfold Relation.Connected
  apply Quotient.ind₂
  intro ⟨a, b, b_nonzero⟩ ⟨c, d, d_nonzero⟩
  intro h'
  -- TODO: Clean up
  have h : a * d ≠ c * b := by
    intro (h'' : ((a, ⟨b, b_nonzero⟩) : ℤ × NonZeroInteger) ≈ (c, ⟨d, d_nonzero⟩))
    exact absurd (Quotient.sound h'') h'
  have bd_nonzero := Integer.multiply_nonzero_of_nonzero b_nonzero d_nonzero
  match less_than_connected h, less_than_connected bd_nonzero with
  | Or.inl hadcb, Or.inl hbd =>
    have := Integer.subtract_negative_of_less_than hadcb
    rw [← Integer.subtract_definition, Integer.negate_multiply_equal_negate_multiply] at this
    exact Or.inr (equal_positive_of_positive_or_negative (Or.inr (And.intro this hbd)))
  | Or.inl hadcb, Or.inr hbd =>
    have := Integer.subtract_positive_of_less_than hadcb
    rw [← Integer.subtract_definition, Integer.negate_multiply_equal_negate_multiply] at this
    rw [Integer.multiply_commutative] at hbd
    exact Or.inl (equal_positive_of_positive_or_negative (Or.inl (And.intro this hbd)))
  | Or.inr hcbad, Or.inl hbd =>
    have := Integer.subtract_negative_of_less_than hcbad
    rw [← Integer.subtract_definition, Integer.negate_multiply_equal_negate_multiply] at this
    rw [Integer.multiply_commutative] at hbd
    exact Or.inl (equal_positive_of_positive_or_negative (Or.inr (And.intro this hbd)))
  | Or.inr hcbad, Or.inr hbd =>
    have this := Integer.subtract_positive_of_less_than hcbad
    rw [← Integer.subtract_definition, Integer.negate_multiply_equal_negate_multiply] at this
    exact Or.inr (equal_positive_of_positive_or_negative (Or.inl (And.intro this hbd)))

theorem LessEqual.reflexive : Relation.Reflexive LessEqual :=
  λ _ => Or.inr rfl
  
theorem LessEqual.antisymmetric : Relation.AntiSymmetric LessEqual :=
  λ hxy hyx =>
    match hxy, hyx with
    | Or.inl hxy, Or.inl hyx => False.elim (LessThan.asymmetric hxy hyx)
    | Or.inl _, Or.inr hyx => hyx.symm
    | Or.inr hxy, _ => hxy
  
theorem LessEqual.transitive : Relation.Transitive LessEqual :=
  λ hxy hyz =>
    match hxy, hyz with
    | Or.inl hxy, Or.inl hyz => Or.inl (LessThan.transitive hxy hyz)
    | Or.inl hxy, Or.inr hyz => Or.inl (hyz ▸ hxy)
    | Or.inr hxy, Or.inl hyz => Or.inl (hxy ▸ hyz)
    | Or.inr hxy, Or.inr hyz => Or.inr (hxy.trans hyz)

theorem LessEqual.strongly_connected : Relation.StronglyConnected LessEqual :=
  λ a b =>
    if h_equal : a = b then
      Or.inl (Or.inr h_equal)
    else
      match LessThan.connected h_equal with
      | Or.inl h_less => Or.inl (Or.inl h_less)
      | Or.inr h_greater => Or.inr (Or.inl h_greater)

instance totalOrder : DecidableTotalOrder Rational where
  less_equal_reflexive := LessEqual.reflexive
  less_equal_antisymmetric := LessEqual.antisymmetric
  less_equal_transitive := LessEqual.transitive
  less_equal_strongly_connected := LessEqual.strongly_connected
  decideEqual := decideEqual
  decideLessEqual := λ _ _ => instDecidableOr
  decideLessThan := decideLessThan
  lt := LessThan
  less_than_equivalent_less_equal_not_less_equal := by
    intro x y
    apply Iff.intro
    . intro hxy
      apply And.intro
      . exact Or.inl hxy
      . intro hyx
        match hyx with
        | Or.inl h_less => exact LessThan.asymmetric hxy h_less
        | Or.inr h_equal => exact absurd (h_equal ▸ hxy) (LessThan.irreflexive x)
    . intro h
      match h.left with
      | Or.inl h_less => exact h_less
      | Or.inr h_equal => exact False.elim (h.right (Or.inr h_equal.symm))
#+end_src

*** Order lemmas

#+begin_src lean4
theorem add_left_strict_monotone : ∀ x : ℚ, StrictMonotone (x + .) := by
  apply Quotient.ind₃
  -- TODO: Rename the variables, this was left over from when it was different
  intro ⟨e, f, f_nonzero⟩ ⟨a, b, b_nonzero⟩ ⟨c, d, d_nonzero⟩ 
  intro ⟨(⟨u, u_positive⟩, ⟨v, v_positive⟩), (h : (c * b + -a * d) * v = u * (d * b))⟩
  apply Exists.intro (⟨u, u_positive⟩, ⟨v, v_positive⟩)
  show ((e*d + c*f)*(f*b) + -(e*b + a*f)*(f*d))*v = u*((f*d)*(f*b))
  -- TODO: Fix
  rw [Integer.right_distributive _ _ (f*b), Integer.negate_add, Integer.right_distributive _ _ (f*d), ← Integer.negate_multiply_equal_negate_multiply, Integer.multiply_associative e d _, Integer.multiply_commutative f b, Integer.multiply_left_commutative d _ _, Integer.multiply_commutative d f, ← Integer.multiply_associative e _ _, Integer.add_right_commutative, ← Integer.add_associative, Integer.add_inverse, Integer.zero_add, ← Integer.negate_multiply_equal_negate_multiply, Integer.multiply_associative, Integer.multiply_commutative f d, Integer.multiply_left_commutative f _ _, ← Integer.multiply_associative, Integer.negate_multiply_equal_negate_multiply, Integer.negate_multiply_equal_negate_multiply, Integer.multiply_associative c f _, Integer.multiply_left_commutative f b f, ← Integer.multiply_associative c _ _, ← Integer.right_distributive, Integer.multiply_right_commutative, Integer.add_commutative, Integer.multiply_associative d, Integer.multiply_left_commutative f b f, ← Integer.multiply_associative u, ← Integer.multiply_associative (u * d), Integer.multiply_associative u]
  exact congrArg (. * (f * f)) h

theorem add_right_strict_monotone : ∀ z : ℚ, StrictMonotone (. + z) := by
  intro z x y h
  simp
  rw [add_commutative x z, add_commutative y z]
  exact add_left_strict_monotone z h
  
theorem less_than_of_add_less_than_left {x y z : ℚ} (h : x + y < x + z) : y < z := by
  have := add_left_strict_monotone (-x) h
  simp [negate_add_cancel_left] at this
  exact this

theorem less_than_of_add_less_than_right {x y z : ℚ} (h : x + z < y + z) : x < y := by
  rw [add_commutative x z, add_commutative y z] at h
  exact less_than_of_add_less_than_left h
  
theorem add_less_than_add {w x y z : ℚ} (hwy : w < y) (hxz : x < z) : w + x < y + z :=
  less_than_transitive (add_right_strict_monotone x hwy) (add_left_strict_monotone y hxz)

theorem less_than_add_of_nonnegative_left {x y : ℚ} (h : 0 < y) : x < y + x := by
  have := add_right_strict_monotone x h
  simp [zero_add] at this
  exact this

theorem less_than_add_of_nonnegative_right {x y : ℚ} (h : 0 < y) : x < x + y := by
  rw [add_commutative x y]
  exact less_than_add_of_nonnegative_left h

theorem less_than_of_subtract_negative {x y : ℚ} (h : x - y < 0) : x < y := by
  have := add_right_strict_monotone y h
  simp at this
  rw [zero_add, ← subtract_definition, negate_add_cancel_right] at this
  exact this

theorem subtract_negative_of_less_than {x y : ℚ} (h : x < y) : x - y < 0 := by
  have := add_right_strict_monotone (-y) h
  simp [subtract_self] at this
  exact this

theorem negate_strict_antitone : StrictAntitone negate := by
  intro x y h
  have hx := add_left_strict_monotone (-y) h
  simp [add_inverse_left] at hx
  have hy := add_right_strict_monotone (-x) hx
  simp at hy
  rw [← subtract_definition, add_negate_cancel_right, zero_subtract] at hy
  exact hy

theorem less_than_of_negate_less_than_negate {x y : ℚ} (h : -y < -x) : x < y :=
  suffices - -x < - -y by simp at this; exact this
  negate_strict_antitone h

-- TODO
theorem multiply_positive_left_strict_monotone : ∀ {x: ℚ}, 0 < x → StrictMonotone (x * .) := by
  apply Quotient.ind
  intro ⟨a, b, b_nonzero⟩
  intro ⟨(⟨s, s_positive⟩, ⟨t, t_positive⟩), (hab : (a*1 + -0*b)*t = s*(b*1))⟩
  apply Quotient.ind₂
  intro ⟨c, d, d_nonzero⟩ ⟨e, f, f_nonzero⟩
  intro ⟨(⟨u, u_positive⟩, ⟨v, v_positive⟩), (hefcd : (e * d + -c * f) * v = u * (f * d))⟩
  rw [Integer.multiply_one, ← Integer.negate_zero, Integer.zero_multiply, Integer.add_zero, Integer.multiply_one] at hab
  apply Exists.intro (⟨u*s, Integer.multiply_positive u_positive s_positive⟩, ⟨v*t, Integer.multiply_positive v_positive t_positive⟩)
  show (a*e*(b*d) + -(a*c)*(b*f))*(v*t) = (u*s)*((b*f)*(b*d))
  rw [Integer.multiply_associative, Integer.multiply_left_commutative e, ← Integer.multiply_associative a, ← Integer.negate_multiply_equal_negate_multiply, Integer.multiply_associative a c, Integer.multiply_left_commutative c, ← Integer.multiply_associative a b, Integer.negate_multiply_equal_multiply_negate, ← Integer.left_distributive, Integer.multiply_commutative, Integer.multiply_commutative v t, Integer.multiply_left_commutative, Integer.multiply_associative t, ← Integer.multiply_associative, Integer.multiply_associative u s, ← Integer.multiply_associative s, ← Integer.multiply_associative s, ← hab, Integer.multiply_associative _ f, Integer.multiply_left_commutative f, ← Integer.multiply_associative _ b, Integer.multiply_left_commutative u, Integer.multiply_commutative v, Integer.negate_multiply_equal_negate_multiply, Integer.multiply_right_commutative a t]
  exact congrArg ((a * b * t) * .) hefcd

theorem multiply_positive_right_strict_monotone : ∀ {z : ℚ}, 0 < z → StrictMonotone (. * z) := by
  intro z hz x y hxy
  simp [multiply_commutative x z, multiply_commutative y z]
  exact multiply_positive_left_strict_monotone hz hxy

theorem multiply_positive {x y : ℚ} (hx : 0 < x) (hy : 0 < y) : 0 < x * y := by
  have := multiply_positive_left_strict_monotone hx hy
  simp [multiply_zero] at this
  exact this

theorem multiply_negative {x y : ℚ} (hx : x < 0) (hy : y < 0) : 0 < x * y := by
  have := multiply_positive_left_strict_monotone (negate_strict_antitone hx) (negate_strict_antitone hy)
  simp at this
  rw [← negate_zero, multiply_zero, ← negate_multiply_equal_negate_multiply, ← negate_multiply_equal_multiply_negate, negate_negate] at this
  exact this

theorem multiply_negative_of_positive_of_negative {x y : ℚ} (hx : 0 < x) (hy : y < 0) : x * y < 0 := by
  rw [← multiply_zero x]
  exact multiply_positive_left_strict_monotone hx hy

theorem multiply_negative_of_negative_of_positive {x y : ℚ} (hx : x < 0) (hy : 0 < y) : x * y < 0 := by
  rw [← zero_multiply y]
  exact multiply_positive_right_strict_monotone hy hx

theorem multiply_less_than_multiply {w x y z : ℚ} (hwy : w < y) (hxz : x < z) (hx : 0 < x) (hy : 0 < y) : w * x < y * z :=
  less_than_transitive
  (multiply_positive_right_strict_monotone hx hwy)
  (multiply_positive_left_strict_monotone hy hxz)

theorem multiply_negative_left_strict_antitone {x : ℚ} (hx : x < 0) : StrictAntitone (x * .) := by
  intro y z h
  have := multiply_positive_left_strict_monotone (negate_strict_antitone hx) h
  simp [← negate_multiply_equal_negate_multiply, ← negate_multiply_equal_negate_multiply] at this
  exact less_than_of_negate_less_than_negate this
  
theorem multiply_negative_right_strict_antitone {z : ℚ} (hz : z < 0) : StrictAntitone (. * z) := by
  intro x y h
  simp [multiply_commutative x z, multiply_commutative y z]
  exact multiply_negative_left_strict_antitone hz h

theorem add_left_monotone (x : ℚ) : Monotone (x + .) := by
  unfold Monotone
  intro y z h
  simp
  match h with
  | Or.inl h => exact Or.inl (add_left_strict_monotone x h)
  | Or.inr h => exact Or.inr (congrArg (x + .) h)

theorem add_right_monotone (z : ℚ) : Monotone (. + z) := by
  intro x y h
  simp
  rw [add_commutative x z, add_commutative y z]
  exact add_left_monotone z h

theorem less_equal_of_add_less_equal_left {x y z : ℚ} (h : x + y ≤ x + z) : y ≤ z := by
  have := add_left_monotone (-x) h
  simp [negate_add_cancel_left] at this
  exact this

theorem less_equal_of_add_less_equal_right {x y z : ℚ} (h : x + z ≤ y + z) : x ≤ y := by
  rw [add_commutative x z, add_commutative y z] at h
  exact less_equal_of_add_less_equal_left h

theorem add_less_equal_add {w x y z : ℚ} (hwy : w ≤ y) (hxz : x ≤ z) : w + x ≤ y + z :=
  less_equal_transitive (add_right_monotone x hwy) (add_left_monotone y hxz)

theorem less_equal_add_of_nonnegative_left {a b : ℚ} (h : 0 ≤ b) : a ≤ b + a := by
  have := add_less_equal_add h (less_equal_reflexive a)
  rw [zero_add] at this
  exact this

theorem less_equal_add_of_nonnegative_right {a b : ℚ} (h : 0 ≤ b) : a ≤ a + b := by
  rw [add_commutative a b]
  exact less_equal_add_of_nonnegative_left h
  
theorem less_equal_of_subtract_nonpositive {a b : ℚ} (h : a - b ≤ 0) : a ≤ b := by
  have := add_right_monotone b h
  simp [zero_add] at this
  rw [← subtract_definition, negate_add_cancel_right] at this
  exact this

theorem subtract_nonpositive_of_less_equal {a b : ℚ} (h : a ≤ b) : a - b ≤ 0 := by
  have := add_right_monotone (-b) h
  simp [subtract_self] at this
  exact this
  
theorem negate_antitone : Antitone negate := by
  intro a b h
  have ha := add_right_monotone (-a) h
  simp [add_inverse, add_commutative] at ha
  have hb := add_right_monotone (-b) ha
  simp at hb
  rw [subtract_self, zero_subtract, ← subtract_definition, ← subtract_definition, add_right_commutative, add_inverse, zero_add] at hb
  exact hb

theorem less_equal_of_negate_less_equal_negate {a b : ℚ} (h : -b ≤ -a) : a ≤ b :=
  suffices - -a ≤ - -b by simp at this; exact this
  negate_antitone h
  
theorem multiply_nonnegative_left_monotone {x : ℚ} (hx : 0 ≤ x) : Monotone (x * .) := by
  unfold Monotone
  intro y z h
  simp at h
  match h, hx with
  | Or.inl h, Or.inl hx => 
    exact Or.inl (multiply_positive_left_strict_monotone hx h)
  | Or.inl _, Or.inr hx => 
    apply less_equal_of_equal
    simp [← hx, zero_multiply]
  | Or.inr h, Or.inl _ =>
    apply less_equal_of_equal
    simp [h]
  | Or.inr _, Or.inr hx =>
    apply less_equal_of_equal
    simp [← hx, zero_multiply]
  
theorem multiply_nonnegative_right_monotone {c : ℚ} (hc : 0 ≤ c) : Monotone (. * c) := by
  unfold Monotone
  intro a b h
  simp
  rw [multiply_commutative a c, multiply_commutative b c]
  exact multiply_nonnegative_left_monotone hc h

theorem multiply_nonnegative {a b : ℚ} (ha : 0 ≤ a) (hb : 0 ≤ b) : 0 ≤ a * b := by
  have := multiply_nonnegative_left_monotone ha hb
  simp [multiply_zero] at this
  exact this
  
theorem multiply_nonpositive {a b : ℚ} (ha : a ≤ 0) (hb : b ≤ 0) : 0 ≤ a * b := by
  have := multiply_nonnegative (negate_antitone ha) (negate_antitone hb)
  rw [negate_definition, negate_definition, ← negate_multiply_equal_multiply_negate, ← negate_multiply_equal_negate_multiply, negate_negate] at this
  exact this

theorem multiply_nonpositive_of_nonnegative_of_nonpositive {a b : ℚ} (ha : 0 ≤ a) (hb : b ≤ 0) : a * b ≤ 0 := by
  rw [← multiply_zero a]
  exact multiply_nonnegative_left_monotone ha hb

theorem multiply_nonpositive_of_nonpositive_of_nonnegative {a b : ℚ} (ha : a ≤ 0) (hb : 0 ≤ b) : a * b ≤ 0 := by
  rw [← zero_multiply b]
  exact multiply_nonnegative_right_monotone hb ha
  
-- Tricky: We only require that c is nonnegative, a is totally cool to be negative because that will make a*b negative which preserves order
theorem multiply_less_equal_multiply {a b c d : ℚ} (hac : a ≤ c) (hbd : b ≤ d) (hb : 0 ≤ b) (hc : 0 ≤ c) : a * b ≤ c * d :=
  less_equal_transitive
  (multiply_nonnegative_right_monotone hb hac)
  (multiply_nonnegative_left_monotone hc hbd)
  
theorem multiply_nonpositive_left_antitone {a : ℚ} (ha : a ≤ 0) : Antitone (a * .) := by
  intro b c h
  have := multiply_nonnegative_left_monotone (negate_antitone ha) h
  simp at this
  rw [← negate_multiply_equal_negate_multiply, ← negate_multiply_equal_negate_multiply] at this
  exact less_equal_of_negate_less_equal_negate this

theorem multiply_nonpositive_right_antitone {c : ℚ} (hc : c ≤ 0) : Antitone (. * c) := by
  intro a b h
  simp
  rw [multiply_commutative a c, multiply_commutative b c]
  exact multiply_nonpositive_left_antitone hc h
#+end_src

*** Absolute value

#+begin_src lean4
def magnitude (x : ℚ) : ℚ := maximum x (-x)

macro:max atomic("|" noWs) a:term noWs "|" : term => `(magnitude $a)

theorem magnitude_negate (x : ℚ) : |-x| = |x| := by
  unfold magnitude 
  rw [negate_negate]

theorem magnitude_nonnegative (x : ℚ) : 0 ≤ |x| := by
  unfold magnitude maximum
  match less_equal_strongly_connected 0 x with
  | Or.inl h =>
    split
    case inl hx => exact less_equal_transitive h hx
    case inr hx => exact h
  | Or.inr h =>
    split
    case inl hx => exact (negate_antitone h)
    case inr hx => 
      apply False.elim 
      exact hx (less_equal_transitive h (negate_antitone h))
  
theorem magnitude_zero : |0| = 0 := rfl

theorem zero_of_magnitude_value_zero {x : ℚ} : |x| = 0 → x = 0 := by
  unfold magnitude maximum
  split
  case inl h =>
    intro h
    have := congrArg negate h
    simp [← negate_zero] at this
    exact this
  case inr h => exact id

theorem magnitude_equal_of_nonnegative {x : ℚ} : 0 ≤ x → |x| = x := by
  intro h
  unfold magnitude maximum
  split
  case inl hx =>
    have hx' := negate_antitone (h.transitive hx)
    simp [← negate_zero] at hx'
    simp [less_equal_antisymmetric hx' h, ← negate_zero]
  case inr hx =>
    rfl

theorem magnitude_equal_negate_of_nonpositive {x : ℚ} : x ≤ 0 → |x| = -x := by
  intro h
  have := negate_antitone h
  simp [← negate_zero] at this
  have foo := magnitude_equal_of_nonnegative this
  
theorem magnitude_equal_of_positive (x : ℚ) : 0 < x → |x| = x :=
  by skip

theorem magnitude_equal_negate_of_negative (x : ℚ) : x < 0 → |x| = -x :=
  by skip
  
-- The triangle inequality
-- If only one of the terms is nonpositive, this decreases the magnitude value, otherwise the two sides are equal
theorem magnitude_add_less_equal (x y : ℚ) : |x + y| ≤ |x| + |y| := by
  skip

theorem magnitude_less_equal_equivalent_negate_less_equal_self {x y : ℚ} :
    -y ≤ x ∧ x ≤ y ↔ |x| ≤ y := by
  apply Iff.intro
  . intro h
    unfold magnitude maximum
    split
    case inl hx =>
      have := negate_antitone h.left
      simp [negate_negate] at this
      exact this
    case inr hx =>
      exact h.right
  . intro h
    unfold magnitude maximum at h
    split at h
    case inl hx =>
      apply And.intro
      . have := negate_antitone h
        simp [negate_negate] at this
        exact this
      . exact less_equal_transitive hx h
    case inr hxy =>
      apply And.intro
      . have := negate_antitone (less_equal_transitive (less_equal_of_not_greater_equal hxy) h)
        simp at this
        exact this
      . exact h
  
theorem magnitude_less_equal_of_negate_less_equal {x y : ℚ} : -y ≤ x → x ≤ y → |x| ≤ y :=
  λ hyx hxy =>
  magnitude_less_equal_equivalent_negate_less_equal_self.mp (And.intro hyx hxy)

theorem negate_less_equal_of_magnitude_less_equal (x y : ℚ) : |x| ≤ y → -y ≤ x ∧ x ≤ y :=
  magnitude_less_equal_equivalent_negate_less_equal_self.mpr
  
theorem magnitude_multiply_equal_multiply_magnitude (x y : ℚ) : |x * y| = |x| * |y| := by
  unfold magnitude maximum
  split
  case inl hxy =>
    match less_equal_strongly_connected x 0, less_equal_strongly_connected y 0 with
    | Or.inl hx, Or.inl hy =>
      -- have := less_equal_transitive hx (negate_antitone hx)
      split
    | Or.inl hx, Or.inr hy => sorry
    | Or.inr hx, Or.inl hy => sorry
    | Or.inr hx, Or.inr hy => sorry
  case inr hxy =>
    match less_equal_strongly_connected x 0, less_equal_strongly_connected y 0 with
    | Or.inl hx, Or.inl hy => sorry
    | Or.inl hx, Or.inr hy => sorry
    | Or.inr hx, Or.inl hy => sorry
    | Or.inr hx, Or.inr hy => sorry
  
theorem magnitude_negate (x : ℚ) : |-x| = |x| := by
  skip
#+end_src

** Utilities
*** Algebra
:PROPERTIES:
:header-args: :tangle Barb/Algebra.lean
:END:

If this project lasts longer than a semester, I hope this module will
become much more substantial. For now, it is a commutative ring definition.

#+begin_src lean4
import Barb.Syntax

class CommutativeRing (α : Type u) extends Zero α, One α, Add α, Mul α, Neg α where
  add_associative : ∀ (x y z : α), (x + y) + z = x + (y + z)
  add_commutative : ∀ (x y : α), x + y = y + x
  add_zero : ∀ (x : α), x + 0 = x
  add_inverse : ∀ (x : α), x + (-x) = 0

  multiply_associative : ∀ (x y z : α), (x * y) * z = x * (y * z)
  multiply_commutative : ∀ (x y : α), x * y = y * x
  -- TODO: Do we need to make sure 1 \ne 0? Answer, yes, see Nontrivial class in mathlib
  multiply_one : ∀ (x : α), x * 1 = x

  left_distributive : ∀ (x y z : α), x * (y + z) = x * y + x * z
  right_distributive : ∀ (x y z : α), (x + y) * z = x * z + y * z

class Field (α : Type u) extends CommutativeRing α where
  -- TODO: Pull out into reciprocal operation class which takes a nonzero proof and has nice Inv-like syntax
  reciprocal : (x : α) → x ≠ 0 → α
  multiply_inverse : ∀ (x : α) (h : x ≠ 0), x * (reciprocal x h) = 1
#+end_src

*** Function
:PROPERTIES:
:header-args: :tangle Barb/Function.lean
:END:

Some essential definitions for functions. Now that I'm reading
/Algebra: Chapter 0/ [cite:@aluffi2009algebra], I'm itching to define
some category theoretic notions in here like mono- and epi- morphisms,
but other things have to come first.

#+begin_src lean4
namespace Function

def Injective (f : α → β) := ∀ {x y}, f x = f y → x = y

def Surjective (f : α → β) := ∀ y, ∃ x, f x = y

def Bijective (f : α → β) := Injective f ∧ Surjective f

-- "g is a left inverse to f," that is, (g ∘ f) = id
def LeftInverse (g : β → α) (f : α → β) := ∀ x : α, (g ∘ f) x = x

-- "g is a right inverse to f," that is, (f ∘ g) = id
def RightInverse (g : β → α) (f : α → β) := LeftInverse f g

-- TODO: Prove that ∃ LeftInverse → Injective
-- TODO: Prove that ∃ RightInverse → Surjective

def Involutive (f : α → α) := LeftInverse f f

@[inline]
def curry : (α × β → φ) → α → β → φ := λ f a b => f (a, b)

@[inline]
def uncurry : (α → β → φ) → α × β → φ := λ f ⟨a, b⟩ => f a b

variable {α : Type u₁} {β : Type u₂} {φ : Type u₃}

@[simp]
theorem curry_uncurry_left_inverse : LeftInverse (curry : (α × β → φ) → α → β → φ) (uncurry : (α → β → φ) → α × β → φ) :=
  λ _ => rfl

@[simp]
theorem uncurry_curry_left_inverse : LeftInverse (uncurry : (α → β → φ) → α × β → φ) (curry : (α × β → φ) → α → β → φ) :=
  λ _ => funext λ _ => rfl

end Function
#+end_src

*** Logic
:PROPERTIES:
:header-args: :tangle Barb/Logic.lean
:END:

**** Exists unique
We need to formalilze a notion of "there exists a unique." If we have a
predicate $p$ on a type $\alpha$, and this claim amounts to showing that there exists
an $x : \alpha$ for which $p$ holds, and then in addition, showing that any
for other $y : \alpha$, $p$ holding for $y$ implies that $x = y$.

#+begin_src lean4
def ExistsUnique (p : α → Prop) := ∃ x, p x ∧ ∀ y, p y → y = x
#+end_src

Then we copy a macro from mathlib without understanding how it works
so that we can have the nice $\exists!$ syntax.

#+begin_src lean4
open Lean TSyntax.Compat in
macro "∃!" xs:explicitBinders ", " b:term : term => expandExplicitBinders ``ExistsUnique xs b

@[app_unexpander ExistsUnique] def unexpandExistsUnique : Lean.PrettyPrinter.Unexpander
  | `($(_) fun $x:ident ↦ ∃! $xs:binderIdent*, $b) => `(∃! $x:ident $xs:binderIdent*, $b)
  | `($(_) fun $x:ident ↦ $b)                      => `(∃! $x:ident, $b)
  | `($(_) fun ($x:ident : $t) ↦ $b)               => `(∃! ($x:ident : $t), $b)
  | _                                               => throw ()
#+end_src

The introduction just takes the object and the two conditions, but the
elimination rule is interesting. Because of proof irrelevance we can
only eliminate into the ~Prop~ universe, so to eliminate existential
quantification we provide a function which in all cases can take the
$x : \alpha$, the proof that $p$ holds for $x$, and the proof of the
uniqueness of $x$, and can transform these into a proof for another
proposition $b$.

#+begin_src lean4
theorem ExistsUnique.introduction {p : α → Prop} (a : α)
  (h₁ : p a) (h₂ : ∀ y, p y → y = a) : ∃! x, p x := ⟨a, h₁, h₂⟩

theorem ExistsUnique.elimination {p : α → Prop} (b : Prop)
  (h₂ : ∃! x, p x) (h₁ : ∀ x, p x → (∀ y, p y → y = x) → b) : b :=
  Exists.elim h₂ (λ w hw => h₁ w hw.left hw.right)
#+end_src

**** Or
Nothing to see here, just some lemmas about disjunction that I've
needed so far.

#+begin_src lean4
theorem or_imply : (a ∨ b → c) ↔ (a → c) ∧ (b → c) :=
  ⟨λ h => ⟨h ∘ .inl, h ∘ .inr⟩, λ ⟨ha, hb⟩ => Or.rec ha hb⟩

theorem not_or : ¬(p ∨ q) ↔ ¬p ∧ ¬q := or_imply

theorem Or.symmetric : a ∨ b → b ∨ a
  | inl a => inr a
  | inr b => inl b

theorem Or.commutative {a b : Prop} : a ∨ b ↔ b ∨ a := ⟨Or.symmetric, Or.symmetric⟩

theorem Or.implies {a b c d : Prop} (f : a → c) (g : b → d) : a ∨ b → c ∨ d
  | inl a => Or.inl (f a)
  | inr b => Or.inr (g b)
  
theorem Or.implies_left {a b c : Prop} (f : a → b) : a ∨ c → b ∨ c
  | inl a => Or.inl (f a)
  | inr c => Or.inr c
  
theorem Or.implies_right {a b c : Prop} (f : b → c) : a ∨ b → a ∨ c
  | inl a => Or.inl a
  | inr b => Or.inr (f b)

theorem Or.resolve_left {a b : Prop} (h : a ∨ b) (not_a : ¬a) : b :=
  match h with
  | Or.inl ha => absurd ha not_a
  | Or.inr hb => hb

theorem Or.resolve_right {a b : Prop} (h : a ∨ b) (not_b : ¬b) : a :=
  match h with
  | Or.inl ha => ha
  | Or.inr hb => absurd hb not_b
#+end_src

**** Relation definitions

This is fun. Here we define a bunch of common binary relations that
you learn in discrete, so we can use them without duplicating code elsewhere.

#+begin_src lean4
namespace Relation

variable {α : Sort u} (r : α → α → Prop)

local infix:50 " ≺ " => r
local notation:50 a:50 " ⊀ " b:50 => ¬(a ≺ b)

def Reflexive := ∀ x, x ≺ x

def Symmetric := ∀ {x y}, x ≺ y → y ≺ x

def Transitive := ∀ {x y z}, x ≺ y → y ≺ z → x ≺ z

def Irreflexive := ∀ x, x ⊀ x

def AntiSymmetric := ∀ {x y}, x ≺ y → y ≺ x → x = y

def Asymmetric := ∀ {x y}, x ≺ y → y ⊀ x

def Connected := ∀ {x y}, x ≠ y → x ≺ y ∨ y ≺ x

def StronglyConnected := ∀ x y, x ≺ y ∨ y ≺ x

end Relation
#+end_src

**** Relator

Some sneaky stuff is going on here. I've felt like I had a grasp on
~LiftFunction~ when I was stating some of the ~Quotient~ theorems, but
not enough to offer any worthwhile exposition on it here right
now. All I will say is that if we have the relations
$R : \alpha \to \beta \to \text{Prop}$ and
$S : \gamma \to \delta \to \text{Prop}$, then the functions
$f : \alpha \to \gamma$ and $g : \beta \to \delta$ induce a relation
$\forall a : \alpha, b : \beta, R(a, b) \to S(f(a), g(b))$.

#+begin_src lean4
namespace Relator

universe u₁ u₂ v₁ v₂
variable {α : Sort u₁} {β : Sort u₂} {γ : Sort v₁} {δ : Sort v₂}
variable (R : α → β → Prop) (S : γ → δ → Prop)

def LiftFunction (f : α → γ) (g : β → δ) : Prop :=
  ∀ {a b}, R a b → S (f a) (g b)

infixr:40 " ⇒ " => LiftFunction

end Relator
#+end_src

*** Order
:PROPERTIES:
:header-args: :tangle Barb/Order.lean
:END:

This file gives definitions for preorders, partial orders, and total
orders, and provides basic lemmas for working with them. For now it
also includes a definition of monotone and antitone functions, but
this should probably have its own module soon.

#+begin_src lean4
import Barb.Logic
#+end_src

A _preorder_ is a binary relation which is reflexive and transitive. A
_partial order_ is a preorder which is also antisymmetric. A
_strict partial order_ is a binary relation which is irreflexive,
asymmetric, and transitive. Each partial order induces a strict
partial order and vice versa. Because type classes suck, it is
difficult to create a sensible organization which accommodates both
directions, so we prioritize the partial order to strict partial order
direction.

We define preorders, partial orders, and strict partial orders
first. We include a default less than definition which we will use to
induce a strict partial order below, and require that any provided
less than definition be logically equivalent to our definition.

#+begin_src lean4
class Preorder (α : Type u) extends LE α, LT α where
  less_equal_reflexive : Relation.Reflexive (. ≤ . : α → α → Prop)
  less_equal_transitive : Relation.Transitive (. ≤ . : α → α → Prop)
  lt := λ a b => a ≤ b ∧ ¬b ≤ a
  less_than_equivalent_less_equal_not_less_equal : ∀ {a b : α},
    lt a b ↔ a ≤ b ∧ ¬b ≤ a := by intros; simp

class PartialOrder (α : Type u) extends Preorder α where
  less_equal_antisymmetric : Relation.AntiSymmetric (. ≤ . : α → α → Prop)

class StrictPartialOrder (α : Type u) extends LT α where
  less_than_irreflexive : Relation.Irreflexive (. < . : α → α → Prop)
  less_than_transitive : Relation.Transitive (. < . : α → α → Prop)
  -- Default proof: apply transitivity to a < b and b < a to get a < a, but this is a contradiction since ¬(a < a) for all a : α.
  less_than_asymmetric : Relation.Asymmetric (. < . : α → α → Prop)
    := λ hab hba => less_than_irreflexive _ (less_than_transitive hab hba)
#+end_src

Then we give a bunch of getters and setters.

#+begin_src lean4
def LessEqual [s : Preorder α] := s.le

def LessThan [s : Preorder α] := s.lt

theorem less_equal_reflexive [Preorder α] : Relation.Reflexive (. ≤ . : α → α → Prop) := Preorder.less_equal_reflexive

theorem less_equal_transitive [Preorder α] : Relation.Transitive (. ≤ . : α → α → Prop) := Preorder.less_equal_transitive

theorem less_than_equivalent_less_equal_not_less_equal [Preorder α] : ∀ {a b : α}, a < b ↔ a ≤ b ∧ ¬b ≤ a := Preorder.less_than_equivalent_less_equal_not_less_equal

theorem less_equal_antisymmetric [PartialOrder α] : Relation.AntiSymmetric (. ≤ . : α → α → Prop) := PartialOrder.less_equal_antisymmetric

theorem less_than_irreflexive [StrictPartialOrder α] : Relation.Irreflexive (. < . : α → α → Prop) := StrictPartialOrder.less_than_irreflexive

theorem less_than_transitive [StrictPartialOrder α] : Relation.Transitive (. < . : α → α → Prop) := StrictPartialOrder.less_than_transitive

theorem less_than_asymmetric [StrictPartialOrder α] : Relation.Asymmetric (. < . : α → α → Prop) := StrictPartialOrder.less_than_asymmetric
#+end_src

The induced relation $a \le b \land \neg b \le a$ we gave above
satisfies the properties of a strict partial order, so every preorder
induces a partial order.

#+begin_src lean4
instance strictPartialOrderOfPreorder [Preorder α] : StrictPartialOrder α where
  lt := LessThan
  less_than_irreflexive :=
    λ _ h => 
    let ⟨hl, hr⟩ := less_than_equivalent_less_equal_not_less_equal.mp h
    absurd hl hr
  less_than_transitive :=
    λ hab hbc =>
    let ⟨hab, hba⟩ := less_than_equivalent_less_equal_not_less_equal.mp hab
    let ⟨hbc, _⟩ := less_than_equivalent_less_equal_not_less_equal.mp hbc
    less_than_equivalent_less_equal_not_less_equal.mpr
    (And.intro (less_equal_transitive hab hbc) (λ hca => absurd (less_equal_transitive hbc hca) hba))
#+end_src

More lemmas.

#+begin_src lean4
theorem less_equal_of_equal [Preorder α] {a b : α} : a = b → a ≤ b := λ h => h ▸ Preorder.less_equal_reflexive a

theorem less_than_of_less_equal_of_not_equal [PartialOrder α] : ∀ {a b : α}, a ≤ b → a ≠ b → a < b
  | _, _, h_less_equal, h_not_equal =>
  less_than_equivalent_less_equal_not_less_equal.mpr (And.intro h_less_equal (mt (less_equal_antisymmetric h_less_equal) h_not_equal))
  
theorem less_equal_of_less_than [Preorder α] : ∀ {a b : α}, a < b → a ≤ b
  | _, _, h => (less_than_equivalent_less_equal_not_less_equal.mp h).left

theorem not_equal_of_less_than [PartialOrder α] {a b : α} (h_less_than : a < b) : a ≠ b :=
  λ h_equal => absurd h_less_than (h_equal ▸ less_than_irreflexive a)
  
theorem less_than_of_less_than_of_less_equal [PartialOrder α] : ∀ {a b c : α}, a < b → b ≤ c → a < c
  | _, _, _, hab, hbc =>
  let ⟨hab, hba⟩ := less_than_equivalent_less_equal_not_less_equal.mp hab
  less_than_equivalent_less_equal_not_less_equal.mpr (And.intro (less_equal_transitive hab hbc) (λ hca => hba (less_equal_transitive hbc hca)))

theorem less_than_of_less_equal_of_less_than [PartialOrder α] : ∀ {a b c : α}, a ≤ b → b < c → a < c
  | _, _, _, hab, hbc =>
  let ⟨hbc, hcb⟩ := less_than_equivalent_less_equal_not_less_equal.mp hbc
  less_than_equivalent_less_equal_not_less_equal.mpr (And.intro (less_equal_transitive hab hbc) (λ hca => hcb (less_equal_transitive hca hab)))

theorem less_equal_of_less_than_or_equal [PartialOrder α] : ∀ {a b : α}, a < b ∨ a = b → a ≤ b
  | _, _, Or.inl h => less_equal_of_less_than h
  | _, _, Or.inr h => less_equal_of_equal h

theorem not_less_equal_of_greater_than [PartialOrder α] {a b : α} (h : a < b) : ¬b ≤ a :=
  (less_than_equivalent_less_equal_not_less_equal.mp h).right

theorem not_less_than_of_greater_equal [PartialOrder α] {a b : α} (h : a ≤ b) : ¬b < a := λ hab => not_less_equal_of_greater_than hab h

theorem less_equal_of_equal_or_less_than [PartialOrder α] : ∀ {a b : α}, a = b ∨ a < b → a ≤ b := less_equal_of_less_than_or_equal ∘ Or.commutative.mp

theorem less_equal_antisymmetric_equivalent_equal [PartialOrder α] : ∀ {a b : α}, a = b ↔ a ≤ b ∧ b ≤ a :=
  ⟨λ h_equal => ⟨less_equal_of_equal h_equal, less_equal_of_equal h_equal.symm⟩, λ ⟨hab, hba⟩ => less_equal_antisymmetric hab hba⟩

instance decideEqualOfDecideLessEqual [PartialOrder α] [DecidableRel (. ≤ . : α → α → Prop)] : DecidableEq α
  | a, b =>
    if hab : a ≤ b then
      if hba : b ≤ a then isTrue (less_equal_antisymmetric hab hba)
      else isFalse λ h_equal => hba (h_equal ▸ less_equal_reflexive a)
    else isFalse λ h_equal => hab (h_equal ▸ less_equal_reflexive a)

instance decideLessThanOfDecideLessEqual [Preorder α] [DecidableRel (. ≤ . : α → α → Prop)] : DecidableRel (. < . : α → α → Prop)
  | a, b =>
    if hab : a ≤ b then
      if hba : b ≤ a then isFalse λ hba' => (less_than_equivalent_less_equal_not_less_equal.mp hba').right hba
      else isTrue (less_than_equivalent_less_equal_not_less_equal.mpr (And.intro hab hba))
    else isFalse (λ hab' => hab (less_equal_of_less_than hab'))

theorem less_than_or_equal_of_less_equal [PartialOrder α] [DecidableRel (. ≤ . : α → α → Prop)] {a b : α} (hab : a ≤ b) : a < b ∨ a = b :=
  if hba : b ≤ a then
    Or.inr (less_equal_antisymmetric hab hba)
  else
    Or.inl (less_than_equivalent_less_equal_not_less_equal.mpr (And.intro hab hba))

theorem equal_or_less_than_of_less_equal [PartialOrder α] [DecidableRel (. ≤ . : α → α → Prop)] :
    ∀ {a b : α}, a ≤ b → a = b ∨ a < b :=
  Or.commutative.mp ∘ less_than_or_equal_of_less_equal

theorem less_equal_equivalent_less_than_or_equal [PartialOrder α] [DecidableRel (. ≤ . : α → α → Prop)] :
    ∀ {a b : α}, a ≤ b ↔ a < b ∨ a = b :=
  ⟨less_than_or_equal_of_less_equal, less_equal_of_less_than_or_equal⟩
#+end_src

Now we define a total order, which adds the property of being strongly
connected to a partial order, and a strict total order, which adds the
property of being connected to a strict partial order. We also include
a notion of decidable versions of these definitions.

#+begin_src lean4
class TotalOrder (α : Type u) extends PartialOrder α where
  less_equal_strongly_connected : Relation.StronglyConnected (. ≤ . : α → α → Prop)

class StrictTotalOrder (α : Type u) extends StrictPartialOrder α where
  less_than_connected : Relation.Connected (. < . : α → α → Prop)

class DecidableTotalOrder (α : Type u) extends TotalOrder α where
  decideLessEqual : DecidableRel (. ≤ . : α → α → Prop)
  decideEqual : DecidableEq α := decideEqualOfDecideLessEqual
  decideLessThan : DecidableRel (. < . : α → α → Prop) := decideLessThanOfDecideLessEqual

class DecidableStrictTotalOrder (α : Type u) extends StrictTotalOrder α where
  decideLessThan : DecidableRel (. < . : α → α → Prop)
  decideEqual : DecidableEq α
#+end_src

#+begin_src lean4
theorem less_equal_strongly_connected [TotalOrder α] : Relation.StronglyConnected (. ≤ . : α → α → Prop) := TotalOrder.less_equal_strongly_connected

theorem less_than_connected [StrictTotalOrder α] : Relation.Connected (. < . : α → α → Prop) := StrictTotalOrder.less_than_connected

instance [DecidableTotalOrder α] : DecidableRel (. ≤ . : α → α → Prop) := DecidableTotalOrder.decideLessEqual

instance [DecidableStrictTotalOrder α] : DecidableRel (. < . : α → α → Prop) := DecidableStrictTotalOrder.decideLessThan

instance [DecidableStrictTotalOrder α] : DecidableEq α := DecidableStrictTotalOrder.decideEqual
#+end_src

A total order induces a strict total order because we proved earlier
that $a \le b \land a \ne b \to a < b$.

#+begin_src lean4
instance strictTotalOrderOfTotalOrder [TotalOrder α] : StrictTotalOrder α where
  less_than_connected :=
    λ h => match less_equal_strongly_connected _ _ with
      | Or.inl hab => Or.inl (less_than_of_less_equal_of_not_equal hab h)
      | Or.inr hba => Or.inr (less_than_of_less_equal_of_not_equal hba h.symm)
#+end_src

#+begin_src lean4
theorem less_equal_of_not_greater_equal [TotalOrder α] {a b : α} : ¬a ≤ b → a ≤ b := 
  Or.resolve_right (less_equal_strongly_connected a b)

theorem less_equal_of_not_less_equal [TotalOrder α] {a b : α} : ¬a ≤ b → b ≤ a := 
  Or.resolve_left (less_equal_strongly_connected a b)

theorem less_than_trichotomous [DecidableTotalOrder α] (a b : α) : a < b ∨ a = b ∨ a > b :=
  Or.elim (less_equal_strongly_connected a b)
    (λ h : a ≤ b => Or.elim (less_than_or_equal_of_less_equal h) Or.inl (Or.inr ∘ Or.inl))
    (λ h : a ≥ b => Or.elim (less_than_or_equal_of_less_equal h) (Or.inr ∘ Or.inr) (Or.inr ∘ Or.inl ∘ Eq.symm))

theorem less_equal_of_not_less_than [DecidableTotalOrder α] {a b : α} (h : ¬a < b) : b ≤ a :=
  match less_than_trichotomous b a with
  | Or.inl h_less => less_equal_of_less_than h_less
  | Or.inr (Or.inl h_equal) => less_equal_of_equal h_equal
  | Or.inr (Or.inr h_greater) => absurd h_greater h

theorem less_than_or_less_equal [DecidableTotalOrder α] (a b : α) : a < b ∨ b ≤ a := by
  match less_than_trichotomous a b with
  | Or.inl h_less => exact Or.inl h_less
  | Or.inr (Or.inl h_equal) => exact Or.inr (less_equal_of_equal h_equal.symm)
  | Or.inr (Or.inr h_greater) => exact Or.inr (less_equal_of_less_than h_greater)

theorem less_equal_or_less_than [DecidableTotalOrder α] (a b : α) : a ≤ b ∨ b < a :=
  Or.symmetric (less_than_or_less_equal b a)
#+end_src

Using the definition of a decidable total order we can give
definitions for the minimum and maximum functions.

#+begin_src lean4
def minimum [DecidableTotalOrder α] (a b : α) := if a ≤ b then a else b

def minimum_definition [DecidableTotalOrder α] (a b : α) : 
    minimum a b = if a ≤ b then a else b := 
  rfl

def maximum [DecidableTotalOrder α] (a b : α) := if a ≤ b then b else a

def maximum_definition [DecidableTotalOrder α] (a b : α) : 
    maximum a b = if a ≤ b then b else a :=
  rfl
#+end_src

#+begin_src lean4
theorem minimum_less_equal_left [DecidableTotalOrder α] (a b : α) : minimum a b ≤ a :=
  if h : a ≤ b
  then by rw [minimum_definition, if_pos h]; exact less_equal_reflexive a
  else by rw [minimum_definition, if_neg h]; exact less_equal_of_not_less_equal h

theorem minimum_less_equal_right [DecidableTotalOrder α] (a b : α) : minimum a b ≤ b :=
  if h : a ≤ b
  then by rw [minimum_definition, if_pos h]; exact h
  else by rw [minimum_definition, if_neg h]; exact less_equal_reflexive b

theorem less_equal_minimum [DecidableTotalOrder α] {a b c : α} (hab : a ≤ b) (hac : a ≤ c) : a ≤ minimum b c :=
  if h : b ≤ c
  then by rw [minimum_definition, if_pos h]; exact hab
  else by rw [minimum_definition, if_neg h]; exact hac

theorem less_equal_maximum_left [DecidableTotalOrder α] (a b : α) : a ≤ maximum a b :=
  if h : a ≤ b
  then by rw [maximum_definition, if_pos h]; exact h
  else by rw [maximum_definition, if_neg h]; exact less_equal_reflexive a

theorem less_equal_maximum_right [DecidableTotalOrder α] (a b : α) : b ≤ maximum a b :=
  if h : a ≤ b
  then by rw [maximum_definition, if_pos h]; exact less_equal_reflexive b
  else by rw [maximum_definition, if_neg h]; exact less_equal_of_not_less_equal h

theorem maximum_less_equal [DecidableTotalOrder α] {a b c : α} (hac : a ≤ c) (hbc : b ≤ c) : maximum a b ≤ c :=
  if h : a ≤ b
  then by rw [maximum_definition, if_pos h]; exact hbc
  else by rw [maximum_definition, if_neg h]; exact hac

theorem equal_minimum [DecidableTotalOrder α] {b c d : α} (hab : b ≤ c) (hac : b ≤ d)
    (hd : ∀ {a}, a ≤ c → a ≤ d → a ≤ b) : b = minimum c d :=
  less_equal_antisymmetric
  (less_equal_minimum hab hac)
  (hd (minimum_less_equal_left c d) (minimum_less_equal_right c d))

theorem minimum_commutative [DecidableTotalOrder α] (a b : α) : minimum a b = minimum b a :=
  equal_minimum 
  (minimum_less_equal_right a b) 
  (minimum_less_equal_left a b)
  (λ hcb hca => less_equal_minimum hca hcb)

theorem minimum_associative [DecidableTotalOrder α] (a b c : α) :
    minimum (minimum a b) c = minimum a (minimum b c) := by
  apply equal_minimum
  . apply less_equal_transitive
    apply minimum_less_equal_left; apply minimum_less_equal_left
  . apply less_equal_minimum
    apply less_equal_transitive; apply minimum_less_equal_left; apply minimum_less_equal_right
    apply minimum_less_equal_right
  . intro d hda hdbc
    apply less_equal_minimum; apply less_equal_minimum hda; apply less_equal_transitive hdbc
    apply minimum_less_equal_left; apply less_equal_transitive hdbc; apply minimum_less_equal_right

@[simp] theorem minimum_self [DecidableTotalOrder α] (a : α) : minimum a a = a := by simp [minimum_definition]

theorem minimum_equal_left [DecidableTotalOrder α] {a b : α} (h : a ≤ b) : minimum a b = a := by
  apply Eq.symm
  apply equal_minimum (less_equal_reflexive a) h
  intro c ha _; exact ha

theorem minimum_equal_right [DecidableTotalOrder α] {a b : α} (h : b ≤ a) : minimum a b = b := by
  apply Eq.symm
  apply equal_minimum h (less_equal_reflexive b)
  intro c _ hb; exact hb

theorem equal_maximum [DecidableTotalOrder α] {a b c : α} (hac : a ≤ c) (hbc : b ≤ c)
    (hd : ∀ {d}, a ≤ d → b ≤ d → c ≤ d) : c = maximum a b :=
  less_equal_antisymmetric
  (hd (less_equal_maximum_left a b) (less_equal_maximum_right a b))
  (maximum_less_equal hac hbc)

theorem maximum_commutative [DecidableTotalOrder α] (a b : α) : maximum a b = maximum b a :=
  equal_maximum
  (less_equal_maximum_right a b)
  (less_equal_maximum_left a b)
  (λ hb ha => maximum_less_equal ha hb)

theorem maximum_associative [DecidableTotalOrder α] (a b c : α) :
    maximum (maximum a b) c = maximum a (maximum b c) := by
    apply equal_maximum
    . apply less_equal_transitive
      apply less_equal_maximum_left a b; apply less_equal_maximum_left
    . apply maximum_less_equal
      apply less_equal_transitive; apply less_equal_maximum_right a b; apply less_equal_maximum_left;
      apply less_equal_maximum_right
    . intro d had hbcd
      apply maximum_less_equal
      apply maximum_less_equal had; apply less_equal_transitive (less_equal_maximum_left _ _) hbcd
      apply less_equal_transitive (less_equal_maximum_right _ _) hbcd

@[simp] theorem maximum_self [DecidableTotalOrder α] (a : α) : maximum a a = a := by simp [maximum_definition]

theorem maximum_equal_left [DecidableTotalOrder α] {a b : α} (h : b ≤ a) : maximum a b = a := by
  apply Eq.symm
  apply equal_maximum (less_equal_reflexive a) h
  intro c ha _; exact ha

theorem maximum_equal_right [DecidableTotalOrder α] {a b : α} (h : a ≤ b) : maximum a b = b := by
  apply Eq.symm
  apply equal_maximum h (less_equal_reflexive b)
  intro c _ hb; exact hb

theorem minimum_equal_left_of_less_than [DecidableTotalOrder α] {a b : α} : a < b → minimum a b = a :=
  minimum_equal_left ∘ less_equal_of_less_than

theorem minimum_equal_right_of_less_than [DecidableTotalOrder α] {a b : α} : b < a → minimum a b = b :=
  minimum_equal_right ∘ less_equal_of_less_than

theorem maximum_equal_left_of_less_than [DecidableTotalOrder α] {a b : α} : b < a → maximum a b = a :=
  maximum_equal_left ∘ less_equal_of_less_than

theorem max_eq_right_of_lt [DecidableTotalOrder α] {a b : α} : a < b → maximum a b = b :=
  maximum_equal_right ∘ less_equal_of_less_than

theorem less_than_minimum [DecidableTotalOrder α] {a b c : α} 
    (hab : a < b) (hac : a < c) : a < minimum b c :=
  Or.elim (less_equal_or_less_than b c)
    (λ h => (minimum_equal_left h).symm ▸ hab)
    (λ h => (minimum_equal_right_of_less_than h).symm ▸ hac)

theorem maximum_less_than [DecidableTotalOrder α] {a b c : α} 
    (hac : a < c) (hbc : b < c) : maximum a b < c :=
  Or.elim (less_equal_or_less_than a b)
    (λ h => (maximum_equal_right h).symm ▸ hbc)
    (λ h => (maximum_equal_left_of_less_than h).symm ▸ hac)
#+end_src

A function $f$ between two preorders is _monotone_ if it preserves
order, that is, if $a \le b$ implies $f(a) \le f(b)$. A function is
_antitone_ if it reverses order. We also define corresponding "strict"
definitions for strict partial orders.

#+begin_src lean4
def Monotone [Preorder α] [Preorder β] (f : α → β) := ∀ {a b : α}, a ≤ b → f a ≤ f b

def Antitone [Preorder α] [Preorder β] (f : α → β) := ∀ {a b : α}, a ≤ b → f b ≤ f a

def StrictMonotone [StrictPartialOrder α] [StrictPartialOrder β] (f : α → β) := ∀ {a b : α}, a < b → f a < f b

def StrictAntitone [StrictPartialOrder α] [StrictPartialOrder β] (f : α → β) := ∀ {a b : α}, a < b → f b < f a
#+end_src

*** Quotient
:PROPERTIES:
:header-args: :tangle Barb/Quotient.lean
:END:


I'm not sure there's much to say here yet. I don't understand what
I've done here enough for writing about it really be useful for me to
write about it. Very interesting stuff here though, quotient types are
subtle and I would definitely like to deepen my understanding here.

#+begin_src lean4
import Barb.Logic

namespace Quot

section

variable {ra : α → α → Prop} {rb : β → β → Prop}
variable {γ : Sort v} {r : α → α → Prop} {s : β → β → Prop} {t : γ → γ → Prop}

notation:arg "⟦" a "⟧" => Quot.mk _ a

@[elab_as_elim]
theorem induction_on {α : Sort u} {r : α → α → Prop} {β : Quot r → Prop} (q : Quot r)
    (h : ∀ a, β (Quot.mk r a)) : β q :=
  Quot.ind h q

def map (f : α → β) (h : (ra ⇒ rb) f f) : Quot ra → Quot rb :=
  Quot.lift (λ x => ⟦f x⟧) (λ x y (h₁ : ra x y) => Quot.sound <| h h₁)

def lift₂ (f : α → β → γ) (hr : ∀ a b₁ b₂, s b₁ b₂ → f a b₁ = f a b₂)
    (hs : ∀ a₁ a₂ b, r a₁ a₂ → f a₁ b = f a₂ b) : Quot r → Quot s → γ :=
  Quot.lift (λ a => Quot.lift (f a) (hr a))
    (λ a₁ a₂ ha => funext λ q => Quot.induction_on q λ b => hs a₁ a₂ b ha)

def liftOn₂ (p : Quot r) (q : Quot s) (f : α → β → γ)
    (hr : ∀ a b₁ b₂, s b₁ b₂ → f a b₁ = f a b₂) (hs : ∀ a₁ a₂ b, r a₁ a₂ → f a₁ b = f a₂ b) : γ :=
  Quot.lift₂ f hr hs p q

def map₂ (f : α → β → γ) (hr : ∀ a b₁ b₂, s b₁ b₂ → t (f a b₁) (f a b₂))
    (hs : ∀ a₁ a₂ b, r a₁ a₂ → t (f a₁ b) (f a₂ b)) : Quot r → Quot s → Quot t :=
  Quot.lift₂ (λ a b => Quot.mk t <| f a b) (λ a b₁ b₂ hb => Quot.sound (hr a b₁ b₂ hb))
    (λ a₁ a₂ b ha => Quot.sound (hs a₁ a₂ b ha))

@[elab_as_elim]
def recOnSubsingleton₂ {φ : Quot r → Quot s → Sort w} [h : ∀ a b, Subsingleton (φ ⟦a⟧ ⟦b⟧)]
    (q₁ : Quot r) (q₂ : Quot s)
    (f : ∀ a b, φ ⟦a⟧ ⟦b⟧) : φ q₁ q₂ := 
  @Quot.recOnSubsingleton _ r
    (λ q => φ q q₂)
    (λ a => Quot.ind (β := λ b => Subsingleton (φ ⟦a⟧ b)) (h a) q₂) q₁
    (λ a => Quot.recOnSubsingleton q₂ (λ b => f a b))

theorem lift_construct (f : α → β) (h : ∀ a b, r a b → f a = f b) (a : α) :
    Quot.lift f h (Quot.mk r a) = f a :=
  rfl

instance lift.decidablePredicate (r : α → α → Prop) (p : α → Prop) (h : ∀ a b, r a b → p a = p b)
    [hp : DecidablePred p] :
    DecidablePred (Quot.lift p h) :=
  λ q => Quot.recOnSubsingleton (motive := λ _ => Decidable _) q hp
  
instance lift₂.decidablePredicate (r : α → α → Prop) (s : β → β → Prop) (p : α → β → Prop)
    (ha : ∀ a b₁ b₂, s b₁ b₂ → p a b₁ = p a b₂) (hb : ∀ a₁ a₂ b, r a₁ a₂ → p a₁ b = p a₂ b)
    [hp : ∀ a, DecidablePred (p a)] (q₁ : Quot r) :
    DecidablePred (Quot.lift₂ p ha hb q₁) :=
  λ q₂ => Quot.recOnSubsingleton₂ q₁ q₂ hp
  
instance (r : α → α → Prop) (q : Quot r) (p : α → Prop) (h : ∀ a b, r a b → p a = p b)
    [DecidablePred p] :
    Decidable (Quot.liftOn q p h) :=
  Quot.lift.decidablePredicate _ _ _ _
  
instance (r : α → α → Prop) (s : β → β → Prop) (q₁ : Quot r) (q₂ : Quot s) (p : α → β → Prop)
    (ha : ∀ a b₁ b₂, s b₁ b₂ → p a b₁ = p a b₂) (hb : ∀ a₁ a₂ b, r a₁ a₂ → p a₁ b = p a₂ b)
    [∀ a, DecidablePred (p a)] :
    Decidable (Quot.liftOn₂ q₁ q₂ p ha hb) :=
  Quot.lift₂.decidablePredicate _ _ _ _ _ _ _

end

end Quot

namespace Quotient

section

variable [sa : Setoid α] [sb : Setoid β] [sc : Setoid γ]

def map (f : α → β) (h : ((· ≈ ·) ⇒ (· ≈ ·)) f f) : Quotient sa → Quotient sb :=
  Quot.map f h

def map₂ (f : α → β → γ) (h : ((· ≈ ·) ⇒ (· ≈ ·) ⇒ (· ≈ ·)) f f) :
    Quotient sa → Quotient sb → Quotient sc :=
  Quotient.lift₂ (λ x y => ⟦(f x y)⟧) (λ _ _ _ _ h₁ h₂ => Quot.sound <| h h₁ h₂)
  
@[elab_as_elim]
def ind₃ {motive : Quotient sa → Quotient sb → Quotient sc → Prop}
  (h : (a : α) → (b : β) → (c : γ) → motive ⟦a⟧ ⟦b⟧ ⟦c⟧)
  (q₁ : Quotient sa)
  (q₂ : Quotient sb)
  (q₃ : Quotient sc)
  : motive q₁ q₂ q₃ := by
  induction q₁ using Quotient.ind
  induction q₂ using Quotient.ind
  induction q₃ using Quotient.ind
  apply h
  
@[simp]
theorem lift_construct (f : α → β) (h : ∀ a b : α, a ≈ b → f a = f b) (x : α) :
    Quotient.lift f h (Quotient.mk sa x) = f x := 
  rfl

@[simp]
theorem lift_construct_on (f : α → β) (h : ∀ a b : α, a ≈ b → f a = f b) (x : α) :
    Quotient.liftOn (Quotient.mk sa x) f h = f x :=
  rfl

@[simp]
theorem equivalent [r : Setoid α] {x y : α} : Quotient.mk r x = ⟦y⟧ ↔ x ≈ y :=
  ⟨Quotient.exact, Quotient.sound⟩

instance lift.decidablePred (p : α → Prop) (h : ∀ a b, a ≈ b → p a = p b) [DecidablePred p] :
    DecidablePred (Quotient.lift p h) :=
  Quot.lift.decidablePredicate _ _ _

instance lift₂.decidablePred (p : α → β → Prop)
    (h : ∀ a₁ b₁ a₂ b₂, a₁ ≈ a₂ → b₁ ≈ b₂ → p a₁ b₁ = p a₂ b₂)
    [hf : ∀ a, DecidablePred (p a)]
    (q₁ : Quotient sa) : DecidablePred (Quotient.lift₂ p h q₁) :=
  λ q₂ ↦ Quotient.recOnSubsingleton₂ q₁ q₂ hf

instance (q : Quotient sa) (p : α → Prop) (h : ∀ a b, a ≈ b → p a = p b) [DecidablePred p] :
    Decidable (Quotient.liftOn q p h) :=
  Quotient.lift.decidablePred _ _ _

instance (q₁ : Quotient sa) (q₂ : Quotient sb) (p : α → β → Prop)
    (h : ∀ a₁ b₁ a₂ b₂, a₁ ≈ a₂ → b₁ ≈ b₂ → p a₁ b₁ = p a₂ b₂) [∀ a, DecidablePred (p a)] :
    Decidable (Quotient.liftOn₂ q₁ q₂ p h) :=
  Quotient.lift₂.decidablePred _ _ _ _

end

end Quotient
#+end_src

*** Syntax
:PROPERTIES:
:header-args: :tangle Barb/Syntax.lean
:END:

Syntax I stole from mathlib when I defined ~CommutativeRing~.

#+begin_src lean4
class Zero.{u} (α : Type u) where
  zero : α

instance Zero.toOfNat0 {α} [Zero α] : OfNat α (nat_lit 0) where
  ofNat := ‹Zero α›.1

instance Zero.ofOfNat0 {α} [OfNat α (nat_lit 0)] : Zero α where
  zero := 0

class One (α : Type u) where
  one : α

instance One.toOfNat1 {α} [One α] : OfNat α (nat_lit 1) where
  ofNat := ‹One α›.1

instance One.ofOfNat1 {α} [OfNat α (nat_lit 1)] : One α where
  one := 1
#+end_src
